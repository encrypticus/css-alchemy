---
title: 'Исчерпывающее руководство по созданию модульной библиотеки, реализующей адаптивную сетку'
date: 2020-06-20 21:26:55
tags:
- scss
- sass
- libs
categories:
- препроцессоры
- scss
- библиотеки
thumbnail: /css-alchemy/img/flexbox-grid-hero2.jpg
include_post_style: post
include_highlight: true
---
include ../../themes/alchemy/layout/components/heading/heading
include _snippets/snippets
-
  const html = snippets.grid.html;
  const sass = snippets.grid.sass;
  const bash= snippets.grid.bash;

p.post__text
  | Эта статья – пошаговое исчерпывающее руководство по созданию собственной "сеточной" системы с использованием препроцессора
  | Sass. Подробно, шаг за шагом я покажу, как создать модульную, гибкую и легко кастомизируемую библиотеку, реализующую
  | адаптивную сетку, наподобие той, что используется в фреймворках Bootstrap, Foundation, Bulma и многих других.
  | Библиотека позволит быстро и без особых усилий создавать адаптивные, отзывчивые макеты. Все примеры кода будут показаны
  | с применением scss-синтаксиса. Итак, приступим!


+heading('Два подхода при построении сетки')
p.post__text При построении сетки используются два основополагающих подхода:
ul.post__list
  li
    span.post__list-item-span
    | Первый подход – в разметке страницы необходимым html-элементам прописываются нужные сеточные классы.
    | Все детали реализации скрыты в CSS:
    +snippet(html[0])
  li
    span.post__list-item-span
    | Второй подход – все необходимые для реализации компонентов сетки правила
    | прописываются в нужных селекторах в стилевом файле:
    +snippet(sass[0], 'css')
    +snippet(html[1])

p.post__text
  | Ни один из подходов не является более или менее правильным по отношению один к другому. У каждого имеются как свои плюсы,
  | так и минусы. Какой из них выбрать – лишь вопрос ваших предпочтений. При первом подходе разметка засоряется большим
  | количеством классов, которые к тому же приходится запоминать. При втором подходе усложняются стили. Мы в своей библиотеке
  | реализуем оба этих подхода – библиотека будет включать как богатый набор предопределенных классов, так и набор готовых
  | sass/scss миксинов и функций, в совокупности реализующих адаптивную сетку.


+heading('Элементы сетки')
p.post__text Каждая сетка должна включать элементы контейнера, рядов и колонок.


+heading('Структура каталогов')
+snippet(bash[0], 'bash')
p.post__text
  span.code grid/
  |  – это основная директория, в которой будет храниться весь код нашей библиотеки
p.post__text
  span.code dist/
  |  – директория содержит скомпилированные минифицированный и неминифицированный css-файлы библиотеки
p.post__text
  span.code sass/
  |  – в этой директории будет храниться код библиотеки в sass-синтаксисе
p.post__text
  span.code scss/
  |  – в этой директории будет храниться код библиотеки в scss-синтаксисе
p.post__text
  span.code mixins/
  |  – директория с миксинами, реализующими основной функционал библиотеки
p.post__text
  span.code partials/
  |  – директория хранит код, отвечающий за генерацию предопределённых готовых классов библиотеки
p.post__text
  span.code base.scss/base.sass/
  |  – этот файл содержит код, отвечающий за начальную инициализацию библиотеки. В нём задаются
  | основные классы: контейнера, ряда, колонки, а также генерируются "колоночные" классы и классы в медиазапросах
p.post__text
  span.code grid.scss/grid.sass
  |  – это так называемая точка входа в библиотеку. Именно этот файл будет указан в поле <span class='code'>main</span>
  | в файле <span class='code'>package.json</span>. Файл будет содержать все глобальные переменные библиотеки, а также
  | подключать все необходимые части библиотеки


+heading('Глобальные переменные')
p.post__text
  | Для того чтобы пользователи нашей библиотеки имели возможность настраивать и кастомизировать сетку, необходимо определить
  | переменные, которые можно будет переопределить и задать им свои значения. Все переменные по умолчанию и внутренние,
  | необходимые для нужд библиотеки переменные будут находиться в основном файле <span class='code'>grid.scss</span>:
+snippet(sass[1], 'scss')

p.post__text
  | Прежде чем подробно рассмотреть каждую переменную, хотелось бы сказать, что почти все объявления переменных,
  | как вы могли заметить, оканчиваются флагом <span class='code'>!default</span>. Размещение этого флага в конце
  | объявления переменной даёт нам следующий эффект – если переменная уже имеет присвоение, она не будет переназначена.
  | Что в свою очередь даёт нам возможность переопределять переменные библиотеки перед её импортом в пользовательский код.
  | Чтобы было понятен смысл сказанного, приведу пример:

p.post__text
  | В файл <span class='code'>index.scss</span> импортируем файл <span class='code'>grid.scss</span>
  | с объявленными в нём переменными, никак их не меняя:
+snippet(sass[2], 'scss')

p.post__text
  | В следующем же примере мы сначала присваиваем значения двум переменным и только потом импортируем файл библиотеки.
  | А так как обе эти переменные внутри <span class='code'>grid.scss</span> объявлены с флагом
  | <span class='code'>!default</span>, значит они примут те значения, которые мы им задали выше. Иными словами мы
  | переопределили значения по умолчанию. Подробнее про директиву <span class='code'>!default</span> можно почитать в
  | официальной <a class='post__link' href='https://sass-lang.com' target='_blank'>документации</a> Sass.
+snippet(sass[3], 'scss')

p.post__text А теперь подробнее рассмотрим наши переменные.
p.post__text
  span.code container-width
  |  – максимальная ширина контейнера сетки

p.post__text
  span.code container-padding
  |  – внутренние горизонтальные отступы контейнера (paddings)

p.post__text
  span.code h-gutter

  |  – внешние горизонтальные отступы между колонками или ячейками сетки (margins)
p.post__text
  span.code v-gutter
  |  – внешние вертикальные отступы между колонками или ячейками сетки (margins)

p.post__text
  span.code columns
  |  – количество колонок, на которые будет разбита наша сетка. По умолчанию она будет состоять из классических
  | двенадцати колонок

p.post__text
  span.code mobile-first
  |  – булева переменная, используемая внутренней служебной функцией <span class='code'>query-direction</span>

p.post__text
  span.code query-direction
  |  – утилитарная внутрення функция, которая возвращает одно из значений - min или max, в зависимости от значения
  |  переменной <span class='code'>mobil-first</span>

p.post__text
  span.code media-query
  |  – это динамическая переменная, которая всегда будет содержать значение, возвращаемое вышеописанной
  | функцией – min или max. Эта переменная будет использоваться при генерации всех медиазапросов библиотеки и определять,
  | какой подход будет применяться при формировании этих медиазапросов - mobile-first или desktop-first.

p.post__text При <span class='code'>$mobile-first: true</span> система будет генерировать такой код:
+snippet(sass[4], 'scss')

p.post__text При <span class='code'>$mobile-first: false</span> такой:
+snippet(sass[5], 'scss')

p.post__text Далее по ходу статьи я ещё остановлюсь более подробно на механизме формирования медиазапросов.

p.post__text
  span.code grid-breakpoints
  |  – массив пар ключ-значение, описывающий набор контрольных точек сетки. По умолчанию наша сетка
  | будет включать восемь контрольных точек. Но мы, так же, как и другие переменные, можем её переопределить, задав более
  | распространённые класические названия и значения контрольных точек:
+snippet(sass[6], 'scss')

p.post__text
  span.code partials
  |  – список тех частей библиотеки, код в которых отвечает за генерирование всех классов сетки. Эти классы
  | необходимы, если мы применим описанный выше первый подход для построения сетки - добавление классов в разметку документа.
  | Если для построения сетки мы будем использовать миксины, то нет необходимости в генерировании большого количества
  | классов, и поэтому мы можем переопределить список, установив его значение в <span class='code'>false</span>. Это
  | значительно сократит скомпилированный css-файл библиотеки.

p.post__text
  | Далее в <span class='code'>grid.scss</span> идёт импорт миксинов, частей и основного файла, инициализирующего библиотеку.


+heading('Создание контейнера сетки')
p.post__text
  | Сетка должна содержать контейнер, определяющий её максимальную ширину, внешние и внутренние отступы. Все сущности сетки
  | будут создаваться при помощи миксинов. Создадим контейнер, поместив следующий код в файл
  | <span class='code'>mixins/_grid.scss</span>:
+snippet(sass[7], 'scss')

p.post__text
  | Мы задали нашему контейнеру максимальную ширину и внешние отступы для его центрирования. Также мы задали контейнеру
  | внутренние отступы, чтобы контент в нём не прилипал к краям браузера. Размеры для ширины и отступов мы взяли из глобальных
  | переменных, определённых в <span class='code'>grid.scss</span>. Теперь мы можем вызвать этот миксин на любом элементе
  | в нашем sass-коде:
+snippet(sass[8], 'scss')

p.post__text
  | Таким образом наш элемент <span class='code'>wrapper</span> теперь является контейнером сетки. Но нам также нужен
  | готовый предопределённый css-класс, реализующий этот же функционал, чтобы мы просто могли прописать его в нашей
  | разметке, не заморачиваясь со стилями. Для этого в файл <span class='code'>base.scss</span> добавим следующий код:
+snippet(sass[9], 'scss')

p.post__text Теперь мы можем прописать этот класс в html-разметке нужному нам элементу:
+snippet(html[2])

p.post__text
  | Наш div также станет контейнером сетки. Подобным образом мы создадим другие наши элементы сетки и её функционал, тем
  | самым реализовав оба подхода - "сетка в html" и "сетка в css".


+heading('Создание ряда сетки')
p.post__text
  | Наряду с контейнером сетка обязательно должна включать такую сущность, как ряд (или строка). Ряд является в свою очередь
  | контейнером для колонок (или ячеек) сетки. Ряд задаёт позиционирование и расположение колонок внутри себя. Сетка может
  | содержать один и более элементов ряда. В <span class='code'>mixins/_grid.scss</span> добавим миксин, создающий ряд:
+snippet(sass[10], 'scss')

p.post__text И не забудем в <span class='code'>base.scss</span> добавить селектор класса для ряда:
+snippet(sass[11], 'scss')

p.post__text
  | Для элемента ряда мы устанавливаем значение <span class='code'>display: flex</span>: это нужно для того, чтобы
  | поставить колонки в ряд. Правило <span class='code'>flex-wrap: wrap</span> мы устанавливаем для того, чтобы, когда
  | для колонок задан размер, они не теснились на одной строке, а переносились на следующую. И наконец внешним горизонтальным
  | отступам мы задаём отрицательное значение. Для чего это нужно? Как было показано выше, в файле
  | <span class='code'>grid.scss</span> мы определили переменную <span class='code'>$h-gutter</span> - расстояние между
  | колонками будущей сетки по горизонтали. По умолчанию оно равно 30px. Забегая вперёд скажу, что для элементов колонок мы
  | установим внешние горизонтальные отступы (margins), равные <span class='code'>$h-gutter / 2</span>, так как марджины у
  | флекс-элементов, каковыми являются наши колонки, внутри флекс-контейнера не схлопываются;
  | <span class='code'>$h-gutter / 2</span> даст нам 15px. То есть по 15px внешнего отступа справа и слева у каждой колонки.
  | Проблема в том, что элементы колонок своими марджинами будут отталкиваться не только друг от друга, но и от правого и
  | левого краёв контейнера, что приведёт к появлению у него лишнего пустого пространства по краям. Это легко проверить,
  | задав контейнеру фоновый цвет:
.post__grid
  .row(style='margin: 0')
    .col.post__col col
    .col.post__col col
    .col.post__col col
  .row(style='margin: 0')
    .col.post__col col
    .col.post__col col
    .col.post__col col
  .row(style='margin:0')
    .col.no-v-gutters.post__col col
    .col.no-v-gutters.post__col col
    .col.no-v-gutters.post__col col

p.post__text
  | Возвращаясь к вопросу, для чего элементу ряда устанавливать отрицательные марджины. Дело в том, что это создаст эффект
  | того, что дочерние элементы колонок как бы провалятся за границы родительского элемента строки:
.post__grid
  .row
    .col.post__col col
    .col.post__col col
    .col.post__col col
  .row
    .col.post__col col
    .col.post__col col
    .col.post__col col
  .row
    .col.no-v-gutters.post__col col
    .col.no-v-gutters.post__col col
    .col.no-v-gutters.post__col col

p.post__text
  | Таким образом первая и последняя колонка в каждом ряду будут вплотную прилегать к краям контейнера. Правило
  | <span class='code'>margin: 0 -\#{$h - gutter / 2};</span> буквально означает – вертикальные марджины установить в значение
  | ноль, а горизонтальным присвоить значение, равное половине значения определённой нами переменной
  | <span class='code'>$h-gutter</span>, то есть 15px; затем инвертировать полученное значение, поставив перед ним знак "–".
  | Знак "#" в Sass означает интерполяцию переменной, подробнее о которой можно почитать в
  | <a class='post__link' href='https://sass-lang.com/' target='_blank'>документации Sass</a>.


+heading('Создание колонки сетки')
p.post__text
  | Последняя неотъемлемая сущность сетки - это колонка. Колонки располагаются внутри рядов. Элемент ряда может содержать
  | один и более элементов колонок. В <span class='code'>mixins/_grid.scss</span> добавим миксин, создающий колонку:
+snippet(sass[12], 'scss')

p.post__text
  | Здесь следует более подробно остановиться на каждом правиле селектора колонки. Правило во второй строке задаёт
  | поведение элемента колонки как flex-элемента. Как мы знаем свойство  <span class='code'>flex</span> - это сокрщённая
  | запись для трёх свойств: <span class='code'>flex-grow</span>, <span class='code'>flex-shrink</span> и
  | <span class='code'>flex-basis</span>. Для <span class='code'>flex-grow</span> мы выставили значение в 1 для того,
  | чтобы колонки были текучими и занимали всё свободное доступное пространство, не сжимаясь под содержащийся в них
  | контент, и чтобы при этом они занимали равные доли свободного пространства. Для <span class='code'>flex-shrink</span>
  | мы установили значение в 0, тем самым переопределив значение по умолчанию, равное 1. Это также сделано для того,
  | чтобы колонки занимали равное пространство, не сжимаясь. И с этой же целью для свойства
  | <span class='code'>flex-basis</span> мы выставили значение в 0%, которое по умолчанию равно auto, что также может
  | привести к сжатию колонки до содержащегося в них контента.

p.post__text
  | Во второй строке свойству <span class='code'>box-sizing</span> мы присвоили значеиние
  | <span class='code'>border-box</span>, что позволит рассчитать значение ширины колонки, включив в неё (ширину) размеры
  | <span class='code'>padding</span>, <span class='code'>margin</span> и <span class='code'>border</span>.
  | То есть размеры внутренних и внешних отступов элемента колонки, а таже размер рамки будут не добавляться к значению
  | ширины, а рассчитываться внутрь элемента.

p.post__text
  | Третьей строкой мы задали внешние горизонтальные и вертикальные отступы, значение которых, как мы помним, равно
  | глобальным  переменным <span class='code'>$h-gutter</span> и <span class='code'>$v-gutter</span> соответственно.

p.post__text Не забываем в <span class='code'>base.scss</span> добавить селектор для колонки:
+snippet(sass[13], 'scss')


+heading('Начальная версия сетки')
p.post__text Ниже представлен полный код, который мы написали к этому моменту.
p.post__text base.scss:
+snippet(sass[14], 'scss')

p.post__text mixins/_grid.scss:
+snippet(sass[15], 'scss')

p.post__text И уже на данном этапе мы можем построить сетку:
p.post__text Прописав нужные классы в html-разметке:
+snippet(html[3])
.container(style='padding: 0;')
  .row
    .col.post__col 1
    .col.post__col 2
    .col.post__col 3
    .col.post__col 4
  .row
    .col.post__col 5
    .col.post__col 6
    .col.post__col 7
    .col.post__col 8
  .row
    .col.post__col 9
    .col.post__col 10
    .col.post__col 11
    .col.post__col 12

p.post__text Или подключив нужные миксины в селекторах в нашем sass-файле:
.row
  +snippet(html[4])(class='col col-phone-landscape-12')
  +snippet(sass[16], scss)(class='col')
.wrap
  .header
    .logo logo
    .nav nav
    .login login
  .main
    .sidebar sidebar
    .content content
    .sidebar sidebar
  .footer
    .logo logo
    .about about
    .email email

p.post__text В первом примере сетка состоит из трёх рядов по четыре колонки в каждом, во втором – из трёх рядов по три колонки.