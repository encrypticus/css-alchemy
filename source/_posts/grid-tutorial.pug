---
title: 'Исчерпывающее руководство по созданию модульной библиотеки, реализующей адаптивную сетку'
date: 2020-06-20 21:26:55
tags:
- scss
- sass
- libs
categories:
- препроцессоры
- scss
- библиотеки
thumbnail: /img/flexbox-grid-hero2.jpg
include_post_style: post
include_highlight: true
---
include ../../themes/alchemy/layout/components/heading/heading
include _snippets/snippets
-
  const html = snippets.grid.html;
  const sass = snippets.grid.sass;
  const bash= snippets.grid.bash;

p.post__text
  | Это первая статья цикла, который представляет собой пошаговое исчерпывающее руководство по созданию собственной
  | "сеточной" системы с использованием препроцессора Sass. Цикл
  | <span style='text-decoration: line-through'>основан на реальных событиях</span> описывает построение
  | <a class='post__link' href='https://www.npmjs.com/package/flexbox-grid-pro' target='_blank'>реально существующей библиотеки</a>.
  | Подробно, шаг за шагом я покажу, как создать модульную, гибкую и легко кастомизируемую библиотеку, реализующую
  | адаптивную сетку, наподобие той, что используется в фреймворках Bootstrap, Foundation, Bulma и многих других.
  | Библиотека позволит быстро и без особых усилий создавать адаптивные, отзывчивые макеты. Все примеры кода будут показаны
  | с применением scss-синтаксиса. Итак, приступим!


+heading('Два подхода при построении сетки')
p.post__text При построении сетки используются два основополагающих подхода:
ul.post__list
  li
    span.post__list-item-span
    | Первый подход – в разметке страницы необходимым html-элементам прописываются нужные сеточные классы.
    | Все детали реализации скрыты в CSS:
    +snippet(html[0])
  li
    span.post__list-item-span
    | Второй подход – все необходимые для реализации компонентов сетки правила
    | прописываются в нужных селекторах в стилевом файле:
    +snippet(sass[0], 'css')
    +snippet(html[1])

p.post__text
  | Ни один из подходов не является более или менее правильным по отношению один к другому. У каждого имеются как свои плюсы,
  | так и минусы. Какой из них выбрать – лишь вопрос ваших предпочтений. При первом подходе разметка засоряется большим
  | количеством классов, которые к тому же приходится запоминать. При втором подходе усложняются стили. Мы в своей библиотеке
  | реализуем оба этих подхода – библиотека будет включать как богатый набор предопределенных классов, так и набор готовых
  | sass/scss миксинов и функций, в совокупности реализующих адаптивную сетку.


+heading('Элементы сетки')
p.post__text Каждая сетка должна включать элементы контейнера, рядов и колонок.


+heading('Структура каталогов')
+snippet(bash[0], 'bash')
p.post__text
  span.code grid/
  |  – это основная директория, в которой будет храниться весь код нашей библиотеки
p.post__text
  span.code dist/
  |  – директория содержит скомпилированные минифицированный и неминифицированный css-файлы библиотеки
p.post__text
  span.code sass/
  |  – в этой директории будет храниться код библиотеки в sass-синтаксисе
p.post__text
  span.code scss/
  |  – в этой директории будет храниться код библиотеки в scss-синтаксисе
p.post__text
  span.code mixins/
  |  – директория с миксинами, реализующими основной функционал библиотеки
p.post__text
  span.code partials/
  |  – директория хранит код, отвечающий за генерацию предопределённых готовых классов библиотеки
p.post__text
  span.code base.scss/base.sass/
  |  – этот файл содержит код, отвечающий за начальную инициализацию библиотеки. В нём задаются
  | основные классы: контейнера, ряда, колонки, а также генерируются "колоночные" классы и классы в медиазапросах
p.post__text
  span.code grid.scss/grid.sass
  |  – это так называемая точка входа в библиотеку. Именно этот файл будет указан в поле <span class='code'>main</span>
  | в файле <span class='code'>package.json</span>. Файл будет содержать все глобальные переменные библиотеки, а также
  | подключать все необходимые части библиотеки


+heading('Глобальные переменные')
p.post__text
  | Для того чтобы пользователи нашей библиотеки имели возможность настраивать и кастомизировать сетку, необходимо определить
  | переменные, которые можно будет переопределить и задать им свои значения. Все переменные по умолчанию и внутренние,
  | необходимые для нужд библиотеки переменные будут находиться в основном файле <span class='code'>grid.scss</span>:
+snippet(sass[1], 'scss')

p.post__text
  | Прежде чем подробно рассмотреть каждую переменную, хотелось бы сказать, что почти все объявления переменных,
  | как вы могли заметить, оканчиваются флагом <span class='code'>!default</span>. Размещение этого флага в конце
  | объявления переменной даёт нам следующий эффект – если переменная уже имеет присвоение, она не будет переназначена.
  | Что в свою очередь даёт нам возможность переопределять переменные библиотеки перед её импортом в пользовательский код.
  | Чтобы было понятен смысл сказанного, приведу пример:

p.post__text
  | В файл <span class='code'>index.scss</span> импортируем файл <span class='code'>grid.scss</span>
  | с объявленными в нём переменными, никак их не меняя:
+snippet(sass[2], 'scss')

p.post__text
  | В следующем же примере мы сначала присваиваем значения двум переменным и только потом импортируем файл библиотеки.
  | А так как обе эти переменные внутри <span class='code'>grid.scss</span> объявлены с флагом
  | <span class='code'>!default</span>, значит они примут те значения, которые мы им задали выше. Иными словами мы
  | переопределили значения по умолчанию. Подробнее про директиву <span class='code'>!default</span> можно почитать в
  | официальной <a class='post__link' href='https://sass-lang.com' target='_blank'>документации</a> Sass.
+snippet(sass[3], 'scss')

p.post__text А теперь подробнее рассмотрим наши переменные.
p.post__text
  span.code container-width
  |  – максимальная ширина контейнера сетки

p.post__text
  span.code container-padding
  |  – внутренние горизонтальные отступы контейнера (paddings)

p.post__text
  span.code h-gutter

  |  – внешние горизонтальные отступы между колонками или ячейками сетки (margins)
p.post__text
  span.code v-gutter
  |  – внешние вертикальные отступы между колонками или ячейками сетки (margins)

p.post__text
  span.code columns
  |  – количество колонок, на которые будет разбита наша сетка. По умолчанию она будет состоять из классических
  | двенадцати колонок

p.post__text
  span.code mobile-first
  |  – булева переменная, используемая внутренней служебной функцией <span class='code'>query-direction</span>

p.post__text
  span.code query-direction
  |  – утилитарная внутрення функция, которая возвращает одно из значений - min или max, в зависимости от значения
  |  переменной <span class='code'>mobil-first</span>

p.post__text
  span.code media-query
  |  – это динамическая переменная, которая всегда будет содержать значение, возвращаемое вышеописанной
  | функцией – min или max. Эта переменная будет использоваться при генерации всех медиазапросов библиотеки и определять,
  | какой подход будет применяться при формировании этих медиазапросов - mobile-first или desktop-first.

p.post__text При <span class='code'>$mobile-first: true</span> система будет генерировать такой код:
+snippet(sass[4], 'scss')

p.post__text При <span class='code'>$mobile-first: false</span> такой:
+snippet(sass[5], 'scss')

p.post__text Далее по ходу статьи я ещё остановлюсь более подробно на механизме формирования медиазапросов.

p.post__text
  span.code grid-breakpoints
  |  – массив пар ключ-значение, описывающий набор контрольных точек сетки. По умолчанию наша сетка
  | будет включать восемь контрольных точек. Но мы, так же, как и другие переменные, можем её переопределить, задав более
  | распространённые класические названия и значения контрольных точек:
+snippet(sass[6], 'scss')

p.post__text
  span.code partials
  |  – список тех частей библиотеки, код в которых отвечает за генерирование всех классов сетки. Эти классы
  | необходимы, если мы применим описанный выше первый подход для построения сетки - добавление классов в разметку документа.
  | Если для построения сетки мы будем использовать миксины, то нет необходимости в генерировании большого количества
  | классов, и поэтому мы можем переопределить список, установив его значение в <span class='code'>false</span>. Это
  | значительно сократит скомпилированный css-файл библиотеки.

p.post__text
  | Далее в <span class='code'>grid.scss</span> идёт импорт миксинов, частей и основного файла, инициализирующего библиотеку.


+heading('Создание контейнера сетки')
p.post__text
  | Сетка должна содержать контейнер, определяющий её максимальную ширину, внешние и внутренние отступы. Все сущности сетки
  | будут создаваться при помощи миксинов. Создадим контейнер, поместив следующий код в файл
  | <span class='code'>mixins/_grid.scss</span>:
+snippet(sass[7], 'scss')

p.post__text
  | Мы задали нашему контейнеру максимальную ширину и внешние отступы для его центрирования. Также мы задали контейнеру
  | внутренние отступы, чтобы контент в нём не прилипал к краям браузера. Размеры для ширины и отступов мы взяли из глобальных
  | переменных, определённых в <span class='code'>grid.scss</span>. Теперь мы можем вызвать этот миксин на любом элементе
  | в нашем sass-коде:
+snippet(sass[8], 'scss')

p.post__text
  | Таким образом наш элемент <span class='code'>wrapper</span> теперь является контейнером сетки. Но нам также нужен
  | готовый предопределённый css-класс, реализующий этот же функционал, чтобы мы просто могли прописать его в нашей
  | разметке, не заморачиваясь со стилями. Для этого в файл <span class='code'>base.scss</span> добавим следующий код:
+snippet(sass[9], 'scss')

p.post__text Теперь мы можем прописать этот класс в html-разметке нужному нам элементу:
+snippet(html[2])

p.post__text
  | Наш div также станет контейнером сетки. Подобным образом мы создадим другие наши элементы сетки и её функционал, тем
  | самым реализовав оба подхода - "сетка в html" и "сетка в css".


+heading('Создание ряда сетки')
p.post__text
  | Наряду с контейнером сетка обязательно должна включать такую сущность, как ряд (или строка). Ряд является в свою очередь
  | контейнером для колонок (или ячеек) сетки. Ряд задаёт позиционирование и расположение колонок внутри себя. Сетка может
  | содержать один и более элементов ряда. В <span class='code'>mixins/_grid.scss</span> добавим миксин, создающий ряд:
+snippet(sass[10], 'scss')

p.post__text И не забудем в <span class='code'>base.scss</span> добавить селектор класса для ряда:
+snippet(sass[11], 'scss')

p.post__text
  | Для элемента ряда мы устанавливаем значение <span class='code'>display: flex</span>: это нужно для того, чтобы
  | поставить колонки в ряд. Правило <span class='code'>flex-wrap: wrap</span> мы устанавливаем для того, чтобы, когда
  | для колонок задан размер, они не теснились на одной строке, а переносились на следующую. И наконец внешним горизонтальным
  | отступам мы задаём отрицательное значение. Для чего это нужно? Как было показано выше, в файле
  | <span class='code'>grid.scss</span> мы определили переменную <span class='code'>$h-gutter</span> - расстояние между
  | колонками будущей сетки по горизонтали. По умолчанию оно равно 30px. Забегая вперёд скажу, что для элементов колонок мы
  | установим внешние горизонтальные отступы (margins), равные <span class='code'>$h-gutter / 2</span>, так как марджины у
  | флекс-элементов, каковыми являются наши колонки, внутри флекс-контейнера не схлопываются;
  | <span class='code'>$h-gutter / 2</span> даст нам 15px. То есть по 15px внешнего отступа справа и слева у каждой колонки.
  | Проблема в том, что элементы колонок своими марджинами будут отталкиваться не только друг от друга, но и от правого и
  | левого краёв контейнера, что приведёт к появлению у него лишнего пустого пространства по краям. Это легко проверить,
  | задав контейнеру фоновый цвет:
.post__grid
  .row(style='margin: 0')
    .col.post__col col
    .col.post__col col
    .col.post__col col
  .row(style='margin: 0')
    .col.post__col col
    .col.post__col col
    .col.post__col col
  .row(style='margin:0')
    .col.no-v-gutters.post__col col
    .col.no-v-gutters.post__col col
    .col.no-v-gutters.post__col col

p.post__text
  | Возвращаясь к вопросу, для чего элементу ряда устанавливать отрицательные марджины. Дело в том, что это создаст эффект
  | того, что дочерние элементы колонок как бы провалятся за границы родительского элемента строки:
.post__grid
  .row
    .col.post__col col
    .col.post__col col
    .col.post__col col
  .row
    .col.post__col col
    .col.post__col col
    .col.post__col col
  .row
    .col.no-v-gutters.post__col col
    .col.no-v-gutters.post__col col
    .col.no-v-gutters.post__col col

p.post__text
  | Таким образом первая и последняя колонка в каждом ряду будут вплотную прилегать к краям контейнера. Правило
  | <span class='code'>margin: 0 -\#{$h - gutter / 2};</span> буквально означает – вертикальные марджины установить в значение
  | ноль, а горизонтальным присвоить значение, равное половине значения определённой нами переменной
  | <span class='code'>$h-gutter</span>, то есть 15px; затем инвертировать полученное значение, поставив перед ним знак "–".
  | Знак "#" в Sass означает интерполяцию переменной, подробнее о которой можно почитать в
  | <a class='post__link' href='https://sass-lang.com/' target='_blank'>документации Sass</a>.


+heading('Создание колонки сетки')
p.post__text
  | Последняя неотъемлемая сущность сетки - это колонка. Колонки располагаются внутри рядов. Элемент ряда может содержать
  | один и более элементов колонок. В <span class='code'>mixins/_grid.scss</span> добавим миксин, создающий колонку:
+snippet(sass[12], 'scss')

p.post__text
  | Здесь следует более подробно остановиться на каждом правиле селектора колонки. Правило во второй строке задаёт
  | поведение элемента колонки как flex-элемента. Как мы знаем свойство  <span class='code'>flex</span> - это сокрщённая
  | запись для трёх свойств: <span class='code'>flex-grow</span>, <span class='code'>flex-shrink</span> и
  | <span class='code'>flex-basis</span>. Для <span class='code'>flex-grow</span> мы выставили значение в 1 для того,
  | чтобы колонки были текучими и занимали всё свободное доступное пространство, не сжимаясь под содержащийся в них
  | контент, и чтобы при этом они занимали равные доли свободного пространства. Для <span class='code'>flex-shrink</span>
  | мы установили значение в 0, тем самым переопределив значение по умолчанию, равное 1. Это также сделано для того,
  | чтобы колонки занимали равное пространство, не сжимаясь. И с этой же целью для свойства
  | <span class='code'>flex-basis</span> мы выставили значение в 0%, которое по умолчанию равно auto, что также может
  | привести к сжатию колонки до содержащегося в них контента.

p.post__text
  | Во второй строке свойству <span class='code'>box-sizing</span> мы присвоили значеиние
  | <span class='code'>border-box</span>, что позволит рассчитать значение ширины колонки, включив в неё (ширину) размеры
  | <span class='code'>padding</span>, <span class='code'>margin</span> и <span class='code'>border</span>.
  | То есть размеры внутренних и внешних отступов элемента колонки, а таже размер рамки будут не добавляться к значению
  | ширины, а рассчитываться внутрь элемента.

p.post__text
  | Третьей строкой мы задали внешние горизонтальные и вертикальные отступы, значение которых, как мы помним, равно
  | глобальным  переменным <span class='code'>$h-gutter</span> и <span class='code'>$v-gutter</span> соответственно.

p.post__text Не забываем в <span class='code'>base.scss</span> добавить селектор для колонки:
+snippet(sass[13], 'scss')


+heading('Начальная версия сетки')
p.post__text Ниже представлен полный код, который мы написали к этому моменту.
p.post__text base.scss:
+snippet(sass[14], 'scss')

p.post__text mixins/_grid.scss:
+snippet(sass[15], 'scss')

p.post__text И уже на данном этапе мы можем построить сетку:
p.post__text Прописав нужные классы в html-разметке:
+snippet(html[3])
.container(style='padding: 0;')
  .row
    .col.post__col 1
    .col.post__col 2
    .col.post__col 3
    .col.post__col 4
  .row
    .col.post__col 5
    .col.post__col 6
    .col.post__col 7
    .col.post__col 8
  .row
    .col.post__col 9
    .col.post__col 10
    .col.post__col 11
    .col.post__col 12

p.post__text Или подключив нужные миксины в селекторах в нашем sass-файле:
.row
  +snippet(html[4])(class='col col-phone-landscape-12')
  +snippet(sass[16], 'scss')(class='col')
.wrap
  .header
    .logo.col logo
    .nav.col nav
    .login.col login
  .main
    .sidebar.col sidebar
    .content.col content
    .sidebar.col sidebar
  .footer
    .logo.col logo
    .about.col about
    .email.col email

p.post__text В первом примере сетка состоит из трёх рядов по четыре колонки в каждом, во втором – из трёх рядов по три колонки.

p.post__text
  | В обоих примерах мы видим, что колонки в одном ряду имеют одинаковую ширину. Причём это поведение не зависит от
  | количества колонок. Сколько бы колонок не находилось в одном ряду, все они будут иметь одинаковую ширину. Ниже
  | представлена сетка, состоящая из двенадцати колонок. Если мы попытаемся просмотреть сайт на устройстве с маленьким
  | экраном или уменьшим окно браузера, то увидим, что колонки при нехватке места переходят на следующий ряд, занимая
  | всё доступное пространство. Это так называемый эффект автоколонок:
.container(style='padding: 0;')
  .row
    .col.post__col 1
    .col.post__col 2
    .col.post__col 3
    .col.post__col 5
    .col.post__col 6
    .col.post__col 7
    .col.post__col 8
    .col.post__col 9
    .col.post__col 10
    .col.post__col 11
    .col.post__col 12


+heading('Разное число колонок')
p.post__text
  | Теперь нам нужно реализовать возможность указывать количество колонок, которое будет занимать тот или иной элемент,
  | что позволит нам рассчитать его ширину. Дополним миксин колонки в файле <span class='code'>mixins/_grid.scss</span>:
+snippet(sass[17], 'scss')

p.post__text
  | Теперь миксин имеет параметр <span class='code'>$cols</span> со значением по умолчанию – количество колонок,
  | занимаемое элементом. Внутри миксина мы проверяем, что значение переданного аргумента – не false и что тип
  | аргумента – число. Далее мы проверяем, что значение аргумента не больше значения переменной
  | <span class='code'>$columns</span>: как мы помним – это глобальная переменная, хранящая количество колонок сетки.
  | Если при передаче аргумента мы укажем число большее, чем установленное  количество колонок, значение переменной
  | <span class='code'>$cols</span> просто будет равно этому количеству.

p.post__text
  | Затем мы указываем ширину колонки, которая рассчитывается по такой нехитрой логике: если принять, что ширина ряда
  | равна100%, а сетка содержит двенадать колонок, то ширина одной колонки равна 100% / 12 = 8,333333333333333%. Дальше
  | значение ширины одной колонки мы умножаем на <span class='code'>$cols</span> – количество необходимых нам колонок.
  | Также не забываем вычесть значение горизонтальных марджинов <span class='code'>$h-gutter</span>. Таким образом мы
  | получаем ширину элемента, равную указанному числу колонок.

p.post__text
  | Что касается свойства  <span class='code'>flex</span>:
  | если при вызове миксина мы указываем количество колонок, то свойству <span class='code'>flex-grow</span> мы должны
  | присвоить значение 0, а свойству <span class='code'>flex-basis</span> – значение <span class='code'>auto</span>.
  | Это нужно для того, чтобы ширина колонок рассчитывалась не автоматически, а согласно числу переданных колонок.

p.post__text
  | Подкрепим теорию практикой, чтобы увидеть результат наших вычислений в действии. Перепишем наш старый пример,
  | содержащий элементы logo, nav, login и другие. Сделаем так, чтобы элементы logo, sidebar, login и email занимали по
  | три колонки, а элементы nav, content и about – по шесть:
+snippet(sass[18], 'scss')
.wrap
  .header
    .logo.col-3 logo
    .nav.col-6 nav
    .login.col-3 login
  .main
    .sidebar.col-3 sidebar
    .content.col-6 content
    .sidebar.col-3 sidebar
  .footer
    .logo.col-3 logo
    .about.col-6 about
    .email.col-3 email

p.post__text
  | Теперь для элементов logo, sidebar, login и email установим ширину в две колонки, а для nav, content и about – в восемь:
+snippet(sass[19], 'scss')
.wrap
  .header
    .logo.col-2 logo
    .nav.col-8 nav
    .login.col-2 login
  .main
    .sidebar.col-2 sidebar
    .content.col-8 content
    .sidebar.col-2 sidebar
  .footer
    .logo.col-2 logo
    .about.col-8 about
    .email.col-2 email



+heading('Генерация готовых колоночных классов')
p.post__text
  | Мы усовершенствовали миксин, создающий колонки. Но нам также нужно добавить код, генерирующий готовые колоночные
  | классы, которые мы сможем использовать в нашей разметке. В <span class='code'>base.scss</span> напишем:
+snippet(sass[20], 'scss')

p.post__text
  | Здесь мы в цикле от одного до <span class='code'>$columns</span> генерируем колоночные классы и правила для них.
  | Как мы помним <span class='code'>$columns</span> – это глобальная переменная, содержащая установленное число колонок
  | сетки. Таким образом у нас сгенерируются классы вида col-1, col-2, col-3 и т. д. Этот код описывает общие правила
  | для всех колоночных классов. Но также для разных классов мы должны задать разную ширину. Ведь очевидно, что элемент,
  | занимающий допустим шесть колонок будет шире элемента, занимающего четыре колонки. Для этого в
  | <span class='code'>mixins/_grid.scss</span> я добавлю такой миксин:
+snippet(sass[21], 'scss')

p.post__text
  | Здесь нет ничего сложного. На вход миксин принимает общее количество колонок сетки и в цикле генерирует колоночные
  | классы и правило, задающее ширину для каждого такого класса.

p.post__text
  | Для упрощения миксина <span class='code'>generate-grid</span> рассчет ширины колонки я решил вынести в отдельную
  | функцию. Хотя это и необязательно. В <span class='code'>mixins/_grid.scss</span> добавим:
+snippet(sass[22], 'scss')

p.post__text
  | И перепишем миксин:
+snippet(sass[23], 'scss')

p.post__text
  | Чтобы сгенерировать колоночные классы и правила для них, нужно вызвать наш миксин. Вызов миксина добавим в
  | <span class='code'>base.scss</span>:
+snippet(sass[24], 'scss')

p.post__text Полный код <span class='code'>base.scss</span> на данный момент:
+snippet(sass[25], 'scss')

p.post__text Полный код <span class='code'>mixins/_grid.scss</span>:
+snippet(sass[26], 'scss')

p.post__text Теперь мы можем строить нашу сетку, лишь добавляя в разметку необходимые классы:
+snippet(html[6])
.container(style='padding: 0')
  .row
    .col-6.post__col col 6
    .col-6.post__col col 6
  .row
    .col-2.post__col col 2
    .col-3.post__col col 3
    .col-4.post__col col 4
    .col-3.post__col col 3


+heading('Колоночные классы в медиазапросах')
p.post__text
  | На данный момент в нашем коде уже реализовано создание контейнера сетки, рядов, колонок одинаковой и заданной ширины.
  | Также для всего этого мы реализовали генерацию предопределённых готовых классов. Заверщающий из основных шагов построения
  | сеточной системы – это добавление медиазапросов. Хотелось бы акцентировать внимание на том, что это именно последний из
  | основных шагов, после реализации которого мы получим в принципе готовую и работоспособную библиотеку. А все шаги, которые
  | мы будем рассматривать далее, будут добавлять дополнительный важный, но не необходимый функционал. Итак, реализуем наш
  | следующий шаг – добавим возможность генерации колонок в медиазапросах. Для начала дополним миксин, создающий колонку:
+snippet(sass[27], 'scss')

p.post__text
  | Как мы видим, у миксина <span class='code'>col</span> появился дополнительный параметр
  | <span class='code'>$breakpoint</span>, по умолчанию равный <span class='code'>false</span>. Внутрь миксина я добавил
  | условие, которое гласит, что если при вызове миксина значение <span class='code'>$breakpoint</span> не равно
  | <span class='code'>false</span>, а равно одному из имён ключей глобального массива
  | <span class='code'>$grid-breakpoints</span> (desktop, laptop, tablet-landscape, phone и т.д.), то css-правила для
  | элемента, на котором был вызван миксин, сработают в медиазапросе. Иными словами, если мы вызовем миксин таким образом:
+snippet(sass[28], 'scss')

p.post__text то получим следующий сгенерированный css-код:
+snippet(sass[29], 'css')

p.post__text
  | Пришло время испытать наш миксин на практике. Предположим, что мне нужно построить сетку, состоящую из шести элементов,
  | расположенных в ряд. Размер каждого элемента равен двум колонкам. При размере вьюпорта 1024px и меньше, размер каждого
  | элемента будет равен трём колонкам, при размере вьюпорта 960px и меньше – четырём колонкам, при размере вьюпорта 768px и
  | меньше – шести колонкам, и наконец, когда размер вьюпорта достигнет 640px, все элементы будут занимать по двенадцать
  | колонок каждый, то есть будут занимать всё доступное пространство. Попроубуйте поизменять размер окна браузера, чтобы
  | увидеть поведение сетки при различных размерах вьюпорта:
.container(style='padding: 0')
  .row
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 1
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 2
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 3
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 4
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 5
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 6

p.post__text А вот код, который позволил построить эту сетку:
.row
  +snippet(html[7])(class='col col-phone-landscape-12')
  +snippet(sass[30], 'scss')(class='col')

p.post__text
  | Давайте более подробно остановимся на миксине <span class='code'>col</span> и посмотрим все возможные варианты его вызова.
ul.post__list
  li Когда мы вызываем миксин без аргументов:
    +snippet('@include col;', 'scss')
    p.post__text то наш элемент получает правила из блока <span class='code'>@else</span>:
    +snippet(sass[31], 'scss')

  li Когда мы вызываем миксин с одним аргументом, который является числом:
    +snippet('@include col(3);', 'scss')
    p.post__text то наш элемент получает правила из блока <span class='code'>@else if</span>:
    +snippet(sass[32], 'scss')

  li
    | Если же при вызове миксина мы передаём ему оба аргумента, при этом значение первого аргумента – число, а значение
    | второго аргумента равно одному из имён ключей глобального массива <span class='code'>$grid-breakpoints</span>
    | (desktop, laptop, phone и т. д.):
    +snippet('@include col(3, laptop);', 'scss')
    p.post__tex то к элементу применятся правила из блока <span class='code'>@if</span>:
    +snippet(sass[33], 'scss')

  li
    | Во всех остальных случаях элемент получит правила из блока <span class='code'>@else</span>, так, как будто миксин
    | был вызван без аргументов.


+heading('Генерация готовых колоночных классов в медиазпросах')
p.post__text
  | Далее по аналогии с тем, как мы создали код, генерирующий классы контейнера, ряда и колонок, мы должны создать код,
  | генерирующий готовые классы колонок с медиазапросами, чтобы иметь возможность строить сетку, просто добавляя классы
  | в нашу html-разметку. В файл <span class='code'>mixins/_grid.scss</span> я добавляю два новых миксина, код которых
  | будет подробно разобран ниже.

p.post__tex mixins/_grid.scss:
+snippet(sass[34], 'scss')

p.post__text Первый миксин вспомогательный и используется внутри второго миксина. Давайте разберём каждый из них более
  | подробно.

p.post__text
  | Миксин <span class='code'>generate-breakpoint</span> генерирует "колоночный" класс вида
  | <span class='code'>.col-tablet-8</span>, <span class='code'>.col-laptop-12</span>,
  | <span class='code'>.col-phone-landscape-3</span>, <span class='code'>.col-desktop-6</span> и т. д. Имя класса
  | генерируется по следующему принципу: к строке '.col-' добавляется название брейкпойнта, которое берется из значения
  | имени одного из ключей глобального массива <span class='code'>$grid-breakpoints</span>. Затем к получившейся строке
  | через дефис добавляется число, означающее количество колонок – .col-laptop-5. Во второй строке для получившегося
  | класса в соответствии с переданнами аргументами в медиазапросе задаются правила.

p.post__text
  | Миксин <span class='code'>generate-grid-breakpoints</span> генерирует все "колоночные" классы сетки и css-правила
  | для них в медиазапросах исходя из глобальной переменной <span class='code'>$columns</span> – заданного количества
  | колонок сетки и глобальной переменной<span class='code'>$grid-breakpoints</span> – ассоциативного массива с
  | брейкпойнтами. Миксин содержит цикл, который выполняет <span class='code'>$cols</span> итераций (по умолчанию 12,
  | в соответсвии количеством колонок сетки). На каждой итерации внутри этого цикла по массиву
  | <span class='code'>$breakpoints</span> вызвается ещё один цикл, внутри которого вызывается миксин
  | <span class='code'>generate-breakpoint</span>, в который  передаются <span class='code'>$i</span> – количество
  | колонок, <span class='code'>$value</span> – ширина экрана и <span class='code'>$name</span> – название брейкпойнта.

p.post__text Вот полный код файла <span class='code'>mixins/_grid.scss</span> с комментариями:
+snippet(sass[35], 'scss')

p.post__tex А это полный код файла <span class='code'>base.scss</span> с учетом генерации классов в медиазапросах:
+snippet(sass[36], 'scss')

p.post__text Теперь мы можем строить сетку не только в sass, но и в html:
+snippet(html[5])
.container(style='padding: 0')
  .row
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 1
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 2
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 3
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 4
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 5
    .col-2.col-laptop-3.col-laptop-md-4.col-tablet-landscape-6.col-phone-landscape-12.post__col 6


+heading('Дальнейшие шаги')
p.post__text
  | К настоящему моменту у нас реализован основной функционал нашей системы – мы можем строить адаптивную сетку с колонками
  | разных размеров. Причём размеры колонок могут меняться в зависимости от размера экрана устройства, так как сетка
  | поддерживает медиазапросы. Хотя данного функционала достаточно для построения гибкой адаптивной сетки, однако его
  | недостаточно, чтобы считать такую сетку полноценной. Поэтому все дальнейшие шаги, которые мы реализуем, как раз и будут
  | направлены на наращивание этого дополнительного функционала.

p.post__text Вот список того, что мы реализуем дальше:
ul.post__list
  li выравнивание колонок внутри ряда
  li направление расположения колонок
  li смещение колонок
  li изменение порядка расположения колонок
  li скрытие и отображение элементов внутри колонок
  li сброс внешних отступов у рядов и колонок

p.post__tex
  | В следующей части мы реализуем модуль, отвечающий за выравнивание колонок. Читайте
  | <a class='post__link' href='/2020/06/21/grid-tutorial-alignment/'>продолжение.</a>