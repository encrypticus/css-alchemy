Эта статья – пошаговое исчерпывающее руководство по созданию собственной системы сеток с использованием препроцессора 
Sass. Подробно, шаг за шагом я покажу, как создать модульную, гибкую и легко кастомизируемую библиотеку, реализующую 
адаптивную сетку, наподобие той, что используется в фреймворках Bootstrap, Foundation, Bulma и многих других.
Библиотека позволит быстро и без особых усилий создавать адаптивные, отзывчивые макеты. Все примеры кода будут показаны 
с применением scss-синтаксиса. Итак, приступим!

# Два подхода при построении сетки
При построении сетки используются два основополагающих подхода:
 - Первый подход – в разметке страницы необходимым html-элементам прописываются нужные сеточные классы. Все детали реализации 
 скрыты в CSS:
```html
<div class="container">
  <div class="row">
    <div class="col-12 col-sm-6 col-md-3 col-xs-2"></div>
    <div class="col col-sm-4 col-md-3 col-xs-1"></div>
  </div>
</div> 
```
  
- Второй подход – все необходимые для реализации компонентов сетки правила прописываются в нужных селекторах в 
стилевом файле:

```css
.card {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -15px;
}
```

```html
<section class="card">
 <div class="card__header"></div>
 <div class="card__body"></div>
 <div class="card__footer"></div>
</section> 
```

Ни один из подходов не является более или менее правильным по отношению один к другому. У каждого имеются как свои плюсы, 
так и минусы. Какой из них выбрать – лишь вопрос ваших предпочтений. При первом подходе разметка засоряется большим 
количеством классов, которые к тому же приходится запоминать. При втором подходе усложняются стили. Мы в своей библиотеке
реализуем оба этих подхода – библиотека будет включать как богатый набор предопределенных классов, так и набор готовых 
sass/scss миксинов и функций, в совокупности реализующих адаптивную сетку.

# Элементы сетки
Каждая сетка должна включать элементы контейнера, рядов и колонок.

# Структура каталогов
```bash
grid/         - корневая директория библиотеки
  dist/       - скомпилированные css-файлы библиотеки
  sass/       - реализиция бибиотеки в sass-синтаксисе
  scss/       - реализация библиотеки в scss-синтаксисе
    mixins/   - миксины библиотеки, реализующие ядро
    partials/ - части библиотеки, реализующие генерацию предопределённых сеточных классов
    base.scss - начальная инициализация сетки
    grid.scss - главный файл, точка входа в библиотеку
```

```grid/``` – это основная директория, в которой будет храниться весь код нашей библиотеки

```dist/``` – директория содержит скомпилированные минифицированный и неминифицированный css-файлы библиотеки

```sass/``` – в этой директории будет храниться код библиотеки в sass-синтаксисе

```scss/``` – в этой директории будет храниться код библиотеки в scss-синтаксисе

```mixins/``` – директория с миксинами, реализующими основной функционал библиотеки

```partials/``` – директория хранит код, отвечающий за генерацию предопределённых готовых классов библиотеки

```base.scss/base.sass``` – этот файл содержит код, отвечающий за начальную инициализацию библиотеки. В нём задаются 
основные классы: контейнера, ряда, колонки, а также генерируются "колоночные" классы и классы в медиазапросах.

```grid.scss/grid.sass``` – это так называемая точка входа в библиотеку. Именно этот файл будет указан в поле ```main``` 
в файле ```package.json```. Файл будет содержать все глобальные переменные библиотеки, а также подключать все необходимые 
части библиотеки.

# Глобальные переменные

Для того чтобы пользователи нашей библиотеки имели возможность настраивать и кастомизировать сетку, необходимо определить 
переменные, которые можно будет переопределить и задать им свои значения. Все переменные по умолчанию и внутренние, 
необходимые для нужд библиотеки переменные будут находиться в основном файле ```grid.scss```:

```scss
$container-width: 1140px !default; // ширина контейнера
$container-padding: 15px !default; // внутренние отступы контейнера
$h-gutter: 30px !default; // расстояние между ячейками сетки по горизонтали
$v-gutter: $h-gutter !default; // расстояние между ячейками сетки по вертикали
$columns: 12 !default; // количество колонок сетки
// флаг, указывающий, какой подход будет использован при формиравнии медиазапросов - mobile first или desktop first
$mobile-first: false !default;

// возвращает ключевое слово min или max, которое будет использовано при формировании всех медиазапросов библиотеки -
// min-width или max-width
@function query-direction() {
  @if($mobile-first) {
    @return min;
  } @else {
    @return max;
  }
}

$media-query: query-direction(); // min или max

$grid-breakpoints: (
  desktop: 1280px,
  laptop: 1024px,
  laptop-md: 960px,
  tablet-landscape: 768px,
  phone-landscape: 640px,
  phone: 480px,
  phone-md: 360px,
  phone-sm: 320px
) !default;

// для уменьшения конечного css-файла можно закомментировать ненужные части ( partials )
$partials: (
  alignment,
  direction,
  hide,
  offset,
  ordering,
  show,
  gutters
) !default;

@import 'mixins/mixins';
@import 'partials/alignment';
@import 'partials/ordering';
@import 'partials/direction';
@import 'partials/hide';
@import 'partials/show';
@import 'partials/offset';
@import 'partials/gutters.scss';
@import 'base';
```

Прежде чем подробно рассмотреть каждую переменную, хотелось бы сказать, что почти все объявления переменных, 
как вы могли заметить, оканчиваются флагом ```!default```. Размещение этого флага в конце объявления переменной даёт нам 
следующий эффект – если переменная уже имеет присвоение, она не будет переназначена. Что в свою очередь даёт нам возможность 
переопределять переменные библиотеки перед её импортом в пользовательский код. Чтобы было понятен смысл сказанного, приведу 
пример:

В файл ```index.scss``` импортируем файл ```grid.scss```:

```scss
@import "grid.scss";
```
Здесь мы просто импортировали файл библиотеки с объявленными в нём переменными, никак их не изменив.

```scss
$container-width: 1600px;
$container-padding: 20px;

@import "grid.scss";
```
Здесь же мы сначала присвоили значения двум переменным и только потом импортировали файл библиотеки. А так как обе эти 
переменные внутри ```grid.scss``` объявлены с флагом ```!default```, значит они примут те значения, которые мы им задали 
выше. Иными словами мы переопределили значения по умолчанию. Подробнее про директиву ```!default``` можно почитать в 
официальной [документации](https://sass-lang.com). А теперь подробнее рассмотрим наши переменные.
- ```container-width``` – максимальная ширина контейнера сетки.
- ```container-padding``` – внутренние горизонтальные отступы контейнера (paddings).
- ```h-gutter``` – внешние горизонтальные отступы между колонками или ячейками сетки (margins).
- ```v-gutter``` – внешние вертикальные отступы между колонками или ячейками сетки (margins).
- ```columns``` – количество колонок, на которые будет разбита наша сетка. По умолчанию она будет состоять из классических 
двенадцати колонок.
- ```mobile-first``` - булева переменная, используемая внутренней служебной функцией ```query-direction```
- ```query-direction``` - утилитарная внутрення функция, которая возвращает одно из значений - min или max, в зависимости 
от значения переменной ```mobil-first```.
- ```media-query``` - это динамическая переменная, которая всегда будет содержать значение, возвращаемое вышеописанной 
функцией - min или max. Эта переменная будет использоваться при генерации всех медиазапросов библиотеки и определять, 
какой подход будет применяться при формировании этих медиазапросов - mobile-first или desktop-first:

  При ```$mobile-first: true``` система будет генерировать такой код:
  ```scss
    @media (min-width: 960px) {
      //content
    }
  ```
  
  При ```$mobile-first: false``` такой:
  ```scss
    @media (max-width: 960px) {
      //content
    }
  ```
  Далее по ходу статьи я ещё остановлюсь более подробно на механизме формирования медиазапросов.
  
- ```grid-breakpoints``` - массив пар ключ-значение, описывающий набор контрольных точек сетки. По умолчанию наша сетка 
будет включать восемь контрольных точек. Но мы, так же, как и другие переменные, можем её переопределить, задав более 
распространённые класические названия и значения контрольных точек:
   ```sass
   $grid-breakpoints: (
    lg: 1140px,
    md: 960px,
    sm: 768px,
    xs: 500px
   );
   ```
 - ```$partials``` - список тех частей библиотеки, код в которых отвечает за генерирование всех классов сетки. Эти классы 
 необходимы, если мы применим описанный выше первый подход для построения сетки - добавление классов в разметку документа. 
 Если для построения сетки мы будем использовать миксины, то нет необходимости в генерировании большого количества 
 классов, и поэтому мы можем переопределить список, установив его значение в ```false```. Это значительно сократит 
 скомпилированный css-файл библиотеки.
 - Далее в ```grid.scss``` идёт импорт миксинов, частей и основного файла, инициализирующего библиотеку.

# Создание контейнера сетки
Сетка должна содержать контейнер, определяющий её максимальную ширину, внешние и внутренние отступы. Все сущности сетки 
будут создаваться при помощи миксинов. Создадим контейнер, поместив следующий код в файл ```mixins/_grid.scss```:

```scss
@mixin container {
  max-width: $container-width;
  margin: 0 auto;
  padding: 0 $container-padding;
}
```
Мы задаём нашему контейнеру максимальную ширину и внешние отступы для его центрирования. Также мы задаём контейнеру 
внутренние отступы, чтобы контент в нём не прилипал к краям браузера. Размеры для ширины и отступов мы взяли из глобальных 
переменных, определённых в ```grid.scss```. Теперь мы можем вызвать этот миксин на любом элементе в нашем sass-коде:

```scss
.wrapper {
  @include container();
}
```
Таким образом наш элемент ```wrapper``` теперь является контейнером сетки. Но нам также нужен готовый предопределённый 
css-класс, реализующий этот же функционал, чтобы мы просто могли прописать его в нашей разметке, не заморачиваясь со стилями. 
Для этого в файл ```base.scss``` добавим следующий код:

```scss
.container {
  @include container;
}
```
Теперь мы можем прописать этот класс в html-разметке нужному нам элементу:

```html
<div class="container"></div> 
```

Наш div также станет контейнером сетки. Подобным образом мы создадим другие наши элементы сетки и её функционал, тем 
самым реализовав оба подхода - "сетка в html" и "сетка в css".

# Создание ряда сетки

Наряду с контейнером сетка обязательно должна включать такую сущность, как ряд (или строка). Ряд является в свою очередь 
контейнером для колонок (или ячеек) сетки. Ряд задаёт позиционирование и расположение колонок внутри себя. Сетка может 
содержать один и более элементов ряда. В ```mixins/_grid.scss``` добавим миксин, создающий ряд:

```scss
@mixin row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$h-gutter / 2};
}
```

И не забудем в ```base.scss``` добавить селектор класса для ряда:

```scss
.row {
  @include row;
}
```

Для элемента ряда мы устанавливаем значение ```display: flex```: это нужно для того, чтобы поставить колонки в ряд. Правило 
```flex-wrap: wrap``` мы устанавливаем для того, чтобы, когда для колонок задан размер, они не теснились на одной строке, 
а переносились на следующую. И наконец внешним горизонтальным отступам мы задаём отрицательное значение. Для чего это 
нужно? Как было показано выше, в файле ```grid.scss``` мы определили переменную ```$h-gutter``` - расстояние между 
колонками будущей сетки по горизонтали. По умолчанию оно равно 30px. Забегая вперёд скажу, что для элементов колонок мы 
установим внешние горизонтальные отступы (margins), равные ```$h-gutter / 2```, так как марджины у флекс-элементов, 
каковыми являются наши колонки, внутри флекс-контейнера не схлопываются; ```$h-gutter / 2``` даст нам 15px. То есть по 
15px внешнего отступа справа и слева у каждой колонки. Проблема в том, что элементы колонок своими марджинами будут 
отталкиваться не только друг от друга, но и от правого и левого краёв контейнера, что приведёт к появлению у него 
ненужных зон. Это продемонстрировано на изображении ниже:

 ```html
картинка, демонстрирующая лишние пустые зоны по краям контейнера
```
Возвращаясь к вопросу, для чего элементу ряда устанавливать отрицательные марджины. Дело в том, что это создаст эффект 
того, что дочерние элементы колонок как бы провалятся за границы родительского элемента строки. Это легко увидеть, задав 
элементу строки фоновый цвет:

```html
картинка или сниппет
```

Таким образом первая и последняя колонка в каждом ряду будут вплотную прилегать к краям контейнера. Правило 
```margin: 0 -#{$h-gutter / 2};``` буквально означает – вертикальные марджины установить в значение ноль, а горизонтальным 
присвоить значение, равное половине значения определённой нами переменной ```$h-gutter```, то есть 15px; затем 
инвертировать полученное значение, поставив перед ним знак "–". Знак "#" в Sass означает интерполяцию переменной, подробнее 
о которой можно почитать в [документации](https://sass-lang.com/).

# Создание колонки сетки

Последняя неотъемлемая сущность сетки - это колонка. Колонки располагаются внутри рядов. Элемент ряда может содержать 
один и более элементов колонок. В ```mixins/_grid.scss``` добавим миксин, создающий колонку:

```scss
mixin col {
  flex: 1 0 0%;
  box-sizing: border-box;
  margin: 0 $h-gutter / 2 $v-gutter;
}
```

Здесь следует более подробно остановиться на каждом правиле селектора колонки. Правило в первой строке задаёт поведение
элемента колонки как flex-элемента. Как мы знаем свойство  ```flex``` - это сокрщённая запись для трёх свойств: 
```flex-grow```, ```flex-shrink``` и ```flex-basis```. Для ```flex-grow``` мы выставили значение в 1 для того, 
чтобы колонки были текучими и занимали всё свободное доступное пространство, не сжимаясь под содержащийся в них контент, 
и чтобы при этом они занимали равные доли свободного пространства. Для ```flex-shrink``` мы установили значение в 0, 
тем самым переопределив значение по умолчанию, равное 1. Это также сделано для того, чтобы колонки занимали равное 
пространство, не сжимаясь. И с этой же целью для свойства ```flex-basis``` мы выставили значение в 0%, которое по 
умолчанию равно auto, что также может привести к сжатию колонки до содержащегося в них контента.

Во второй строке свойству ```box-sizing``` мы присвоили значеиние ```border-box```, что позволит рассчитать значение 
ширины колонки, включив в неё (ширину) размеры ```padding```, ```margin``` и ```border```. То есть размеры внутренних и 
внешних отступов элемента колонки, а таже размер рамки будут не добавляться к значению ширины, а рассчитываться внутрь 
элемента.

Третьей строкой мы задали внешние горизонтальные и вертикальные отступы, значение которых, как мы помним, равно глобальным 
переменным ```$h-gutter``` и ```$v-gutter``` соответственно.

Не забываем в ```base.scss``` добавить селектор для колонки:
  ```scss
  .col {
    @include col;
  }
  ```
# Начальная версия сетки
Ниже представлен полный код, который мы написали к этому моменту:

```base.scss```:

```scss
.container {
  @include container;
}

.row {
  @include row;
}

.col {
  @include col;
}
```

```mixins/_grid.scss```:

```scss
@mixin container {
  max-width: $container-width;
  margin: 0 auto;
  padding: 0 $container-padding;
}

@mixin row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$h-gutter / 2};
}

mixin col {
  flex: 1 0 0%;
  box-sizing: border-box;
  margin: 0 $h-gutter / 2 $v-gutter;
}
```

И уже на данном этапе мы можем построить сетку:

Прописав нужные классы в html-разметке:

```scss
сниппет
```

```bash
пример сетки
```

Подключив нужные миксины в селекторах в нашем sass-файле:

```scss
.wrap {
  @include container;
}

.header,
.main,
.footer {
  @include row;
}

.sidebar,
.content,
.logo,
.nav,
.login,
.about,
.email {
  @include col;
}
```
В первом примере сетка состоит из трёх рядов по четыре колонки в каждом, во втором – из трёх рядов по три колонки.

В обоих примерах мы видим, что колонки в одном ряду имеют одинаковую ширину. Причём это поведение не зависит от количества 
колонок. Сколько бы колонок не находилось в одном ряду, все они будут иметь одинаковую ширину.

```html
пример
```
Теперь нам нужно реализовать возможность указывать количество колонок, которое будет занимать тот или иной элемент, что 
позволит нам рассчитать его ширину. Дополним миксин колонки в файле ```mixins/_grid.scss```:

```scss
@mixin col($cols: 'false') {
  @if ($cols != 'false' and type_of($cols) == number) {
    @if ($cols > $columns) $cols: $columns;
  
    width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  } @else {
    flex: 1 0 0%;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}
```
Теперь миксин имеет параметр ```$cols``` со значением по умолчанию – количество колонок, занимаемое элементом. Внутри 
миксина мы проверяем, что значение переданного аргумента – не false и что тип аргумента – число. Далее мы проверяем, что 
значение аргумента не больше значения переменной ```$columns```: как мы помним – это глобальная переменная, хранящая 
количество колонок сетки. Если при передаче аргумента мы укажем число большее, чем установленное количество колонок, 
значение переменной ```$cols``` просто будет равно этому количеству.

Затем мы указываем ширину колонки, которая рассчитывается по такой нехитрой логике: если принять, что ширина ряда равна 
100%, а сетка содержит двенадать колонок, то ширина одной колонки равна 100% / 12 = 8,333333333333333%. Дальше значение 
ширины одной колонки мы умножаем на ```$cols``` – количество необходимых нам колонок. Также не забываем вычесть значение 
горизонтальных марджинов ```$h-gutter```. Таким образом мы получаем ширину элемента, равную указанному числу колонок. 
Что касается свойства  ```flex```: если при вызове миксина мы указываем количество колонок, то свойству ```flex-grow``` 
мы должны присвоить значение 0, а свойству ```flex-basis``` – значение ```auto```. Это нужно для того, чтобы ширина 
колонок рассчитывалась не автоматически, а согласно числу переданных колонок. Подкрепим теорию практикой, чтобы увидеть 
результат наших вычислений в действии. Перепишем наш старый пример, содержащий элементы logo, nav, login и другие. Сделаем 
так, чтобы элементы logo, sidebar, login и email занимали по три колонки, а элементы nav, content и about – по шесть:

```scss
.wrap {
  @include container;
}

.header,
.main,
.footer {
  @include row;
}

.logo,
.sidebar,
.login,
.email {
  @include col(3);
}

.nav,
.content,
.about {
  @include col(6);
}
```

```bash
пример
```

Теперь для элементов logo, sidebar, login и email установим ширину в две колонки, а для nav, content и about – в пять:

```scss
.wrap {
  @include container;
}

.header,
.main,
.footer {
  @include row;
}

.logo,
.sidebar,
.login,
.email {
  @include col(2);
}

.nav,
.content,
.about {
  @include col(5);
}
```

```bash
пример
```