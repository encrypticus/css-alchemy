Эта статья – пошаговое исчерпывающее руководство по созданию собственной системы сеток с использованием препроцессора 
Sass. Подробно, шаг за шагом я покажу, как создать модульную, гибкую и легко кастомизируемую библиотеку, реализующую 
адаптивную сетку, наподобие той, что используется в фреймворках Bootstrap, Foundation, Bulma и многих других.
Библиотека позволит быстро и без особых усилий создавать адаптивные, отзывчивые макеты. Все примеры кода будут показаны 
с применением scss-синтаксиса. Итак, приступим!

# Два подхода при построении сетки
При построении сетки используются два основополагающих подхода:
 - Первый подход – в разметке страницы необходимым html-элементам прописываются нужные сеточные классы. Все детали реализации 
 скрыты в CSS:
```html
<div class="container">
  <div class="row">
    <div class="col-12 col-sm-6 col-md-3 col-xs-2"></div>
    <div class="col col-sm-4 col-md-3 col-xs-1"></div>
  </div>
</div> 
```
  
- Второй подход – все необходимые для реализации компонентов сетки правила прописываются в нужных селекторах в 
стилевом файле:

```css
.card {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -15px;
}
```

```html
<section class="card">
 <div class="card__header"></div>
 <div class="card__body"></div>
 <div class="card__footer"></div>
</section> 
```

Ни один из подходов не является более или менее правильным по отношению один к другому. У каждого имеются как свои плюсы, 
так и минусы. Какой из них выбрать – лишь вопрос ваших предпочтений. При первом подходе разметка засоряется большим 
количеством классов, которые к тому же приходится запоминать. При втором подходе усложняются стили. Мы в своей библиотеке
реализуем оба этих подхода – библиотека будет включать как богатый набор предопределенных классов, так и набор готовых 
sass/scss миксинов и функций, в совокупности реализующих адаптивную сетку.

# Элементы сетки
Каждая сетка должна включать элементы контейнера, рядов и колонок.

# Структура каталогов
```bash
grid/         - корневая директория библиотеки
  dist/       - скомпилированные css-файлы библиотеки
  sass/       - реализиция бибиотеки в sass-синтаксисе
  scss/       - реализация библиотеки в scss-синтаксисе
    mixins/   - миксины библиотеки, реализующие ядро
    partials/ - части библиотеки, реализующие генерацию предопределённых сеточных классов
    base.scss - начальная инициализация сетки
    grid.scss - главный файл, точка входа в библиотеку
```

```grid/``` – это основная директория, в которой будет храниться весь код нашей библиотеки

```dist/``` – директория содержит скомпилированные минифицированный и неминифицированный css-файлы библиотеки

```sass/``` – в этой директории будет храниться код библиотеки в sass-синтаксисе

```scss/``` – в этой директории будет храниться код библиотеки в scss-синтаксисе

```mixins/``` – директория с миксинами, реализующими основной функционал библиотеки

```partials/``` – директория хранит код, отвечающий за генерацию предопределённых готовых классов библиотеки

```base.scss/base.sass``` – этот файл содержит код, отвечающий за начальную инициализацию библиотеки. В нём задаются 
основные классы: контейнера, ряда, колонки, а также генерируются "колоночные" классы и классы в медиазапросах.

```grid.scss/grid.sass``` – это так называемая точка входа в библиотеку. Именно этот файл будет указан в поле ```main``` 
в файле ```package.json```. Файл будет содержать все глобальные переменные библиотеки, а также подключать все необходимые 
части библиотеки.

# Глобальные переменные

Для того чтобы пользователи нашей библиотеки имели возможность настраивать и кастомизировать сетку, необходимо определить 
переменные, которые можно будет переопределить и задать им свои значения. Все переменные по умолчанию и внутренние, 
необходимые для нужд библиотеки переменные будут находиться в основном файле ```grid.scss```:

```scss
$container-width: 1140px !default; // ширина контейнера
$container-padding: 15px !default; // внутренние отступы контейнера
$h-gutter: 30px !default; // расстояние между ячейками сетки по горизонтали
$v-gutter: $h-gutter !default; // расстояние между ячейками сетки по вертикали
$columns: 12 !default; // количество колонок сетки
// флаг, указывающий, какой подход будет использован при формиравнии медиазапросов - mobile first или desktop first
$mobile-first: false !default;

// возвращает ключевое слово min или max, которое будет использовано при формировании всех медиазапросов библиотеки -
// min-width или max-width
@function query-direction() {
  @if($mobile-first) {
    @return min;
  } @else {
    @return max;
  }
}

$media-query: query-direction(); // min или max

$grid-breakpoints: (
  desktop: 1280px,
  laptop: 1024px,
  laptop-md: 960px,
  tablet-landscape: 768px,
  phone-landscape: 640px,
  phone: 480px,
  phone-md: 360px,
  phone-sm: 320px
) !default;

// для уменьшения конечного css-файла можно закомментировать ненужные части ( partials )
$partials: (
  alignment,
  direction,
  hide,
  offset,
  ordering,
  show,
  gutters
) !default;

@import 'mixins/mixins';
@import 'partials/alignment';
@import 'partials/ordering';
@import 'partials/direction';
@import 'partials/hide';
@import 'partials/show';
@import 'partials/offset';
@import 'partials/gutters.scss';
@import 'base';
```

Прежде чем подробно рассмотреть каждую переменную, хотелось бы сказать, что почти все объявления переменных, 
как вы могли заметить, оканчиваются флагом ```!default```. Размещение этого флага в конце объявления переменной даёт нам 
следующий эффект – если переменная уже имеет присвоение, она не будет переназначена. Что в свою очередь даёт нам возможность 
переопределять переменные библиотеки перед её импортом в пользовательский код. Чтобы было понятен смысл сказанного, приведу 
пример:

В файл ```index.scss``` импортируем файл ```grid.scss```:

```scss
@import "grid.scss";
```
Здесь мы просто импортировали файл библиотеки с объявленными в нём переменными, никак их не изменив.

```scss
$container-width: 1600px;
$container-padding: 20px;

@import "grid.scss";
```
Здесь же мы сначала присвоили значения двум переменным и только потом импортировали файл библиотеки. А так как обе эти 
переменные внутри ```grid.scss``` объявлены с флагом ```!default```, значит они примут те значения, которые мы им задали 
выше. Иными словами мы переопределили значения по умолчанию. Подробнее про директиву ```!default``` можно почитать в 
официальной [документации](https://sass-lang.com). А теперь подробнее рассмотрим наши переменные.
- ```container-width``` – максимальная ширина контейнера сетки.
- ```container-padding``` – внутренние горизонтальные отступы контейнера (paddings).
- ```h-gutter``` – внешние горизонтальные отступы между колонками или ячейками сетки (margins).
- ```v-gutter``` – внешние вертикальные отступы между колонками или ячейками сетки (margins).
- ```columns``` – количество колонок, на которые будет разбита наша сетка. По умолчанию она будет состоять из классических 
двенадцати колонок.
- ```mobile-first``` - булева переменная, используемая внутренней служебной функцией ```query-direction```
- ```query-direction``` - утилитарная внутрення функция, которая возвращает одно из значений - min или max, в зависимости 
от значения переменной ```mobil-first```.
- ```media-query``` - это динамическая переменная, которая всегда будет содержать значение, возвращаемое вышеописанной 
функцией - min или max. Эта переменная будет использоваться при генерации всех медиазапросов библиотеки и определять, 
какой подход будет применяться при формировании этих медиазапросов - mobile-first или desktop-first:

  При ```$mobile-first: true``` система будет генерировать такой код:
  ```scss
    @media (min-width: 960px) {
      //content
    }
  ```
  
  При ```$mobile-first: false``` такой:
  ```scss
    @media (max-width: 960px) {
      //content
    }
  ```
  Далее по ходу статьи я ещё остановлюсь более подробно на механизме формирования медиазапросов.
  
- ```grid-breakpoints``` - массив пар ключ-значение, описывающий набор контрольных точек сетки. По умолчанию наша сетка 
будет включать восемь контрольных точек. Но мы, так же, как и другие переменные, можем её переопределить, задав более 
распространённые класические названия и значения контрольных точек:
   ```sass
   $grid-breakpoints: (
    lg: 1140px,
    md: 960px,
    sm: 768px,
    xs: 500px
   );
   ```
 - ```$partials``` - список тех частей библиотеки, код в которых отвечает за генерирование всех классов сетки. Эти классы 
 необходимы, если мы применим описанный выше первый подход для построения сетки - добавление классов в разметку документа. 
 Если для построения сетки мы будем использовать миксины, то нет необходимости в генерировании большого количества 
 классов, и поэтому мы можем переопределить список, установив его значение в ```false```. Это значительно сократит 
 скомпилированный css-файл библиотеки.
 - Далее в ```grid.scss``` идёт импорт миксинов, частей и основного файла, инициализирующего библиотеку.

# Создание контейнера сетки
Сетка должна содержать контейнер, определяющий её максимальную ширину, внешние и внутренние отступы. Все сущности сетки 
будут создаваться при помощи миксинов. Создадим контейнер, поместив следующий код в файл ```mixins/_grid.scss```:

```scss
@mixin container {
  max-width: $container-width;
  margin: 0 auto;
  padding: 0 $container-padding;
}
```
Мы задаём нашему контейнеру максимальную ширину и внешние отступы для его центрирования. Также мы задаём контейнеру 
внутренние отступы, чтобы контент в нём не прилипал к краям браузера. Размеры для ширины и отступов мы взяли из глобальных 
переменных, определённых в ```grid.scss```. Теперь мы можем вызвать этот миксин на любом элементе в нашем sass-коде:

```scss
.wrapper {
  @include container();
}
```
Таким образом наш элемент ```wrapper``` теперь является контейнером сетки. Но нам также нужен готовый предопределённый 
css-класс, реализующий этот же функционал, чтобы мы просто могли прописать его в нашей разметке, не заморачиваясь со стилями. 
Для этого в файл ```base.scss``` добавим следующий код:

```scss
.container {
  @include container;
}
```
Теперь мы можем прописать этот класс в html-разметке нужному нам элементу:

```html
<div class="container"></div> 
```

Наш div также станет контейнером сетки. Подобным образом мы создадим другие наши элементы сетки и её функционал, тем 
самым реализовав оба подхода - "сетка в html" и "сетка в css".

# Создание ряда сетки

Наряду с контейнером сетка обязательно должна включать такую сущность, как ряд (или строка). Ряд является в свою очередь 
контейнером для колонок (или ячеек) сетки. Ряд задаёт позиционирование и расположение колонок внутри себя. Сетка может 
содержать один и более элементов ряда. В ```mixins/_grid.scss``` добавим миксин, создающий ряд:

```scss
@mixin row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$h-gutter / 2};
}
```

И не забудем в ```base.scss``` добавить селектор класса для ряда:

```scss
.row {
  @include row;
}
```

Для элемента ряда мы устанавливаем значение ```display: flex```: это нужно для того, чтобы поставить колонки в ряд. Правило 
```flex-wrap: wrap``` мы устанавливаем для того, чтобы, когда для колонок задан размер, они не теснились на одной строке, 
а переносились на следующую. И наконец внешним горизонтальным отступам мы задаём отрицательное значение. Для чего это 
нужно? Как было показано выше, в файле ```grid.scss``` мы определили переменную ```$h-gutter``` - расстояние между 
колонками будущей сетки по горизонтали. По умолчанию оно равно 30px. Забегая вперёд скажу, что для элементов колонок мы 
установим внешние горизонтальные отступы (margins), равные ```$h-gutter / 2```, так как марджины у флекс-элементов, 
каковыми являются наши колонки, внутри флекс-контейнера не схлопываются; ```$h-gutter / 2``` даст нам 15px. То есть по 
15px внешнего отступа справа и слева у каждой колонки. Проблема в том, что элементы колонок своими марджинами будут 
отталкиваться не только друг от друга, но и от правого и левого краёв контейнера, что приведёт к появлению у него 
ненужных зон. Это продемонстрировано на изображении ниже:

 ```html
картинка, демонстрирующая лишние пустые зоны по краям контейнера
```
Возвращаясь к вопросу, для чего элементу ряда устанавливать отрицательные марджины. Дело в том, что это создаст эффект 
того, что дочерние элементы колонок как бы провалятся за границы родительского элемента строки. Это легко увидеть, задав 
элементу строки фоновый цвет:

```html
картинка или сниппет
```

Таким образом первая и последняя колонка в каждом ряду будут вплотную прилегать к краям контейнера. Правило 
```margin: 0 -#{$h-gutter / 2};``` буквально означает – вертикальные марджины установить в значение ноль, а горизонтальным 
присвоить значение, равное половине значения определённой нами переменной ```$h-gutter```, то есть 15px; затем 
инвертировать полученное значение, поставив перед ним знак "–". Знак "#" в Sass означает интерполяцию переменной, подробнее 
о которой можно почитать в [документации](https://sass-lang.com/).

# Создание колонки сетки

Последняя неотъемлемая сущность сетки - это колонка. Колонки располагаются внутри рядов. Элемент ряда может содержать 
один и более элементов колонок. В ```mixins/_grid.scss``` добавим миксин, создающий колонку:

```scss
mixin col {
  flex: 1 0 0%;
  box-sizing: border-box;
  margin: 0 $h-gutter / 2 $v-gutter;
}
```

Здесь следует более подробно остановиться на каждом правиле селектора колонки. Правило в первой строке задаёт поведение
элемента колонки как flex-элемента. Как мы знаем свойство  ```flex``` - это сокрщённая запись для трёх свойств: 
```flex-grow```, ```flex-shrink``` и ```flex-basis```. Для ```flex-grow``` мы выставили значение в 1 для того, 
чтобы колонки были текучими и занимали всё свободное доступное пространство, не сжимаясь под содержащийся в них контент, 
и чтобы при этом они занимали равные доли свободного пространства. Для ```flex-shrink``` мы установили значение в 0, 
тем самым переопределив значение по умолчанию, равное 1. Это также сделано для того, чтобы колонки занимали равное 
пространство, не сжимаясь. И с этой же целью для свойства ```flex-basis``` мы выставили значение в 0%, которое по 
умолчанию равно auto, что также может привести к сжатию колонки до содержащегося в них контента.

Во второй строке свойству ```box-sizing``` мы присвоили значеиние ```border-box```, что позволит рассчитать значение 
ширины колонки, включив в неё (ширину) размеры ```padding```, ```margin``` и ```border```. То есть размеры внутренних и 
внешних отступов элемента колонки, а таже размер рамки будут не добавляться к значению ширины, а рассчитываться внутрь 
элемента.

Третьей строкой мы задали внешние горизонтальные и вертикальные отступы, значение которых, как мы помним, равно глобальным 
переменным ```$h-gutter``` и ```$v-gutter``` соответственно.

Не забываем в ```base.scss``` добавить селектор для колонки:
  ```scss
  .col {
    @include col;
  }
  ```
# Начальная версия сетки
Ниже представлен полный код, который мы написали к этому моменту:

```base.scss```:

```scss
.container {
  @include container;
}

.row {
  @include row;
}

.col {
  @include col;
}
```

```mixins/_grid.scss```:

```scss
@mixin container {
  max-width: $container-width;
  margin: 0 auto;
  padding: 0 $container-padding;
}

@mixin row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$h-gutter / 2};
}

mixin col {
  flex: 1 0 0%;
  box-sizing: border-box;
  margin: 0 $h-gutter / 2 $v-gutter;
}
```

И уже на данном этапе мы можем построить сетку:

Прописав нужные классы в html-разметке:

```scss
сниппет
```

```bash
пример сетки
```

Подключив нужные миксины в селекторах в нашем sass-файле:

```scss
.wrap {
  @include container;
}

.header,
.main,
.footer {
  @include row;
}

.sidebar,
.content,
.logo,
.nav,
.login,
.about,
.email {
  @include col;
}
```
В первом примере сетка состоит из трёх рядов по четыре колонки в каждом, во втором – из трёх рядов по три колонки.

В обоих примерах мы видим, что колонки в одном ряду имеют одинаковую ширину. Причём это поведение не зависит от количества 
колонок. Сколько бы колонок не находилось в одном ряду, все они будут иметь одинаковую ширину.

```html
пример
```
Теперь нам нужно реализовать возможность указывать количество колонок, которое будет занимать тот или иной элемент, что 
позволит нам рассчитать его ширину. Дополним миксин колонки в файле ```mixins/_grid.scss```:

```scss
@mixin col($cols: 'false') {
  @if ($cols != 'false' and type_of($cols) == number) {
    @if ($cols > $columns) $cols: $columns;
  
    width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  } @else {
    flex: 1 0 0%;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}
```
Теперь миксин имеет параметр ```$cols``` со значением по умолчанию – количество колонок, занимаемое элементом. Внутри 
миксина мы проверяем, что значение переданного аргумента – не false и что тип аргумента – число. Далее мы проверяем, что 
значение аргумента не больше значения переменной ```$columns```: как мы помним – это глобальная переменная, хранящая 
количество колонок сетки. Если при передаче аргумента мы укажем число большее, чем установленное количество колонок, 
значение переменной ```$cols``` просто будет равно этому количеству.

Затем мы указываем ширину колонки, которая рассчитывается по такой нехитрой логике: если принять, что ширина ряда равна 
100%, а сетка содержит двенадать колонок, то ширина одной колонки равна 100% / 12 = 8,333333333333333%. Дальше значение 
ширины одной колонки мы умножаем на ```$cols``` – количество необходимых нам колонок. Также не забываем вычесть значение 
горизонтальных марджинов ```$h-gutter```. Таким образом мы получаем ширину элемента, равную указанному числу колонок. 
Что касается свойства  ```flex```: если при вызове миксина мы указываем количество колонок, то свойству ```flex-grow``` 
мы должны присвоить значение 0, а свойству ```flex-basis``` – значение ```auto```. Это нужно для того, чтобы ширина 
колонок рассчитывалась не автоматически, а согласно числу переданных колонок. Подкрепим теорию практикой, чтобы увидеть 
результат наших вычислений в действии. Перепишем наш старый пример, содержащий элементы logo, nav, login и другие. Сделаем 
так, чтобы элементы logo, sidebar, login и email занимали по три колонки, а элементы nav, content и about – по шесть:

```scss
.wrap {
  @include container;
}

.header,
.main,
.footer {
  @include row;
}

.logo,
.sidebar,
.login,
.email {
  @include col(3);
}

.nav,
.content,
.about {
  @include col(6);
}
```

```bash
пример
```

Теперь для элементов logo, sidebar, login и email установим ширину в две колонки, а для nav, content и about – в восемь:

```scss
.wrap {
  @include container;
}

.header,
.main,
.footer {
  @include row;
}

.logo,
.sidebar,
.login,
.email {
  @include col(2);
}

.nav,
.content,
.about {
  @include col(5);
}
```

```bash
пример
```

# Генерация готовых колоночных классов

Мы усовершенствовали миксин, создающий колонки. Но нам также нужно добавить код, генерирующий готовые колоночные классы, 
которые мы сможем использовать в нашей разметке. В <span class='code'>base.scss</span> напишем:

```scss
@for $i from 1 through $columns {
  .col-#{$i} {
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}
```

Здесь мы в цикле от одного до ```$columns``` генерируем колоночные классы и правила для них. Как мы помним ```$columns``` 
– это глобальная переменная, содержащая установленное число колонок сетки. Таким образом у нас сгенерируются классы вида 
col-1, col-2, col-3 и т. д. Этот код описывает общие правила для всех колоночных классов. Но также для разных классов
мы должны задать разную ширину. Ведь очевидно, что элемент, занимающий допустим шесть колонок будет шире элемента, 
занимающего четыре колонки. Для этого в ```mixins/_grid.scss``` я добавлю такой миксин:

```scss
@mixin generate-grid($cols: $columns) {
  @for $i from 1 through $cols {
    .col-#{$i} {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    }
  }
}
```

Здесь нет ничего сложного. На вход миксин принимает общее количество колонок сетки и в цикле генерирует колоночные классы 
и правило, задающее ширину для каждого такого класса.

Для упрощения миксина ```generate-grid``` рассчет ширины колонки я решил вынести в отдельную функцию. Хотя это и 
необязательно. В ```mixins/_grid.scss``` добавим:

```scss
@function col-width($cols: 1) {
  @return calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
}
```

И перепишем миксин:

```scss
@mixin generate-grid($cols: $columns) {
  @for $i from 1 through $cols {
    .col-#{$i} {
      width: col-width($i);
    }
  }
}
```

Чтобы сгенерировать колоночные классы и правила для них, нужно вызвать наш миксин. Вызов миксина добавим в ```base.scss```: 

```scss
@include generate-grid();
```
Полный код ```base.scss``` на данный момент:

```scss
.container {
  @include container;
}

.row {
  @include row;
}

.col {
  @include col;
}

/*
  Генерация "колоночных" классов и правил для них исходя из глобальной переменной $columns - заданного количества
  столбцов сетки
*/
@for $i from 1 through $columns {
  .col-#{$i} {
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}

// генерация "колоночных" классов
@include generate-grid();
```

Полный код ```mixins/_grid.scss```:

```scss
// превращает элемент в контейнер сетки
@mixin container {
  max-width: $container-width;
  margin: 0 auto;
  padding: 0 $container-padding;
}

// превращает элемент в строку сетки
@mixin row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$h-gutter / 2};
}

// превращает элемент в колонку сетки
@mixin col($cols: 'false') {
  @if ($cols != 'false' and type_of($cols) == number) {
    @if ($cols > $columns) $cols: $columns;
 
    width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  } @else {
    flex: 1 0 0%;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}

// рассчитывает ширину столбца в зависимости от переданного количества столбцов $cols
@function col-width($cols: 1) {
  @return calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
}

/*
  Генерирует "колоночные" классы вида .col-1, .col-2, .col-3 и т.д. исходя из глабальной переменной $columns - заданного
  количества колонок сетки
*/
@mixin generate-grid($cols: $columns) {
  @for $i from 1 through $cols {
    .col-#{$i} {
      width: col-width($i);
    }
  }
}
```
Теперь мы можем строить нашу сетку, лишь добавляя в разметку необходимые классы:

```html
<div class="container">
  <div class="row">
    <div class="col-6"></div>
    <div class="col-6"></div>
  </div>
  
  <div class="row">
    <div class="col-2"></div>
    <div class="col-4"></div>
    <div class="col-5"></div>
    <div class="col-1"></div>
  </div>
</div> 
```

# Колоночные классы в медиазапросах

На данный момент в нашем коде уже реализовано создание контейнера сетки, рядов, колонок одинаковой и заданной ширины. 
Также для всего этого мы реализовали генерацию предопределённых готовых классов. Заверщающий из основных шагов построения 
сеточной системы – это добавление медиазапросов. Хотелось бы акцентировать внимание на том, что это именно последний из 
основных шагов, после реализации которого мы получим в принципе готовую и работоспособную библиотеку. А все шаги, которые 
мы будем рассматривать далее, будут добавлять дополнительный важный, но не необходимый функционал. Итак, реализуем наш 
следующий шаг – добавим возможность генерации колонок в медиазапросах. Для начала дополним миксин, создающий колонку:

```scss
@mixin col($cols: 'false', $breakpoint: 'false') {

  @if ($breakpoint != 'false' and map_has_key($grid-breakpoints, $breakpoint) and $cols != 'false' and type_of($cols) == number) {

    @media screen and(#{$media-query}-width: map-get($grid-breakpoints, $breakpoint)) {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
      flex: 0 0 auto;
      box-sizing: border-box;
      margin: 0 $h-gutter / 2 $v-gutter;
    }

  } @else if ($breakpoint == 'false' and $cols != 'false' and type_of($cols) == number) {
    width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  } @else {
    flex: 1 0 0%;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}
```

Как мы видим, у миксина ```col``` появился дополнительный параметр ```$breakpoint```, по умолчанию равный ```false```. 
Внутрь миксина я добавил условие, которое гласит, что если при вызове миксина значение ```$breakpoint``` не равно
```false```, а равно одному из имён ключей глобального массива ```$grid-breakpoints``` (desktop, laptop, tablet-landscape, 
phone и т.д.), то css-правила для элемента, на котором был вызван миксин, сработают в медиазапросе. Иными словами, если 
мы вызовем миксин таким образом:

```scss
@include col(8, laptop);
```

то получим следующий сгенерированный css-код:

```css
@media screen and (max-width: 1024px) {
  width: calc(100% / 12 * 8 - 30px);
  flex: 0 0 auto;
  box-sizing: border-box;
  margin: 0 15px 15px;
}
```

Здесь стоит отметить, что в правиле ```@media``` значение ширины, как мы видим, было задано через ```max-width```. Это 
поведение по умолчанию и зависит, как я упоминал вначале, от глобальной переменной ```$mobile-first``` в файле 
```grid.scss```. Если перед импортом библиотеки переопределить переменную и присвоить ей значение ```true```:

```scss
$mobile-first: true;

@import "grid.scss";
```

то получим следующий код:

```css
@media screen and (min-width: 1024px) {
  width: calc(100% / 12 * 8 - 30px);
  flex: 0 0 auto;
  box-sizing: border-box;
  margin: 0 15px 15px;
}
```

Пришло время испытать наш миксин на практике. Предположим, что мне нужно построить сетку, состоящую из шести элементов, 
расположенных в ряд. Размер каждого элемента равен двум колонкам. При размере вьюпорта 1024px и меньше, размер каждого 
элемента будет равен трём колонкам, при размере вьюпорта 960px и меньше – четырём колонкам, при размере вьюпорта 768px и 
меньше – шести колонкам, и наконец, когда размер вьюпорта достигнет 640px, все элементы будут занимать по двенадцать 
колонок каждый, то есть будут занимать всё доступное пространство. Попроубуйте поизменять размер окна браузера, чтобы 
увидеть поведение сетки при различных размерах вьюпорта:

```html
<div class="container">
  <div class="row">
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">1</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">2</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">3</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">4</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">5</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">6</div>
  </div>
</div>
```

А вот код, который позволил построить эту сетку:

```scss
 .wrap {
   @include container;
 }
 
 .inner {
   @include row;
 }
 
 .column {
   @include col(2);
   @include col(3, laptop);
   @include col(4, laptop-md);
   @include col(6, tablet-landscape);
   @include col(12, phone-landscape);
 }
```

Давайте более подробно остановимся на миксине ```col``` и посмотрим все возможные варианты его вызова.

 - Когда мы вызываем миксин без аргументов:
 
   ```scss
   @include col;
   ```
   
   то наш элемент получает правила из блока ```@else```:
   
   ```scss
   flex: 1 0 0%;
   box-sizing: border-box;
   margin: 0 $h-gutter / 2 $v-gutter;
   ```
   
 - Когда мы вызываем миксин с одним аргументом, который является числом:
   
   ```scss
   @include col(3);
   ```
   то наш элемент получает правила из блока ```@else if```:
   
   ```scss
   width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
   flex: 0 0 auto;
   box-sizing: border-box;
   margin: 0 $h-gutter / 2 $v-gutter;
   ```
 - Если же при вызове миксина мы передаём ему оба аргумента, при этом значение первого аргумента – число, а значение 
   второго аргумента равно одному из имён ключей глобального массива ```$grid-breakpoints``` (desktop, laptop, phone и т. д.):
   
   ```scss
   @include col(3, laptop);
   ```
   
   то к элементу применятся правила из блока ```@if```:
   
   ```scss
   @media screen and(#{$media-query}-width: map-get($grid-breakpoints, $breakpoint)) {
     width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
     flex: 0 0 auto;
     box-sizing: border-box;
     margin: 0 $h-gutter / 2 $v-gutter;
   }
   ```
   
 - Во всех остальных случаях элемент получит правила из блока ```@else```, так, как будто миксин был вызван без аргументов.
 
# Генерация готовых колоночных классов в медиазпросах

Далее по аналогии с тем, как мы создали код, генерирующий классы контейнера, ряда и колонок, мы должны создать код, 
генерирующий готовые классы колонок с медиазапросами, чтобы иметь возможность строить сетку, просто добавляя классы в нашу
html-разметку. В файл ```mixins/_grid.scss``` я добавляю два новых миксина, код которых будет подробно разобран ниже.

mixins/_grid.scss:

```scss
@mixin generate-breakpoint($cols, $screen-width, $name) {
  .col-#{$name}-#{$cols} {
    @media screen and (#{$media-query}-width: $screen-width) {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter}) !important;
      flex: auto 0 0;
    }
  }
}

@mixin generate-grid-breakpoints($cols: $columns, $breakpoints: $grid-breakpoints) {
  @for $i from 1 through $cols {
    @each $name, $value in $breakpoints {
      @include generate-breakpoint($i, $value, $name);
    }
  }
}
```

Первый миксин вспомогательный и используется внутри второго миксина. Давайте разберём каждый из них более 
подробно. 

Миксин ```generate-breakpoint``` генерирует "колоночный" класс вида ```.col-tablet-8```, ```.col-laptop-12```, 
```.col-phone-landscape-3```, ```.col-desktop-6``` и т. д. Имя класса генерируется по следующему принципу: к строке '.col-' 
добавляется название брейкпойнта, которое берется из значения имени одного из ключей глобального массива 
```$grid-breakpoints```. Затем к получившейся строке через дефис добавляется число, означающее количество колонок – 
.col-laptop-5. Во второй строке для получившегося класса в соответствии с переданнами аргументами в медиазапросе задаются 
правила.

Миксин ```generate-grid-breakpoints``` генерирует все "колоночные" классы сетки и css-правила для них в медиазапросах 
исходя из глобальной переменной $columns – заданного количества колонок сетки и глобальной переменной 
```$grid-breakpoints``` – ассоциативного массива с брейкпойнтами. Миксин содержит цикл, который выполняет ```$cols``` 
итераций (по умолчанию 12, в соответсвии количеством колонок сетки). На каждой итерации внутри этого цикла по массиву 
```$breakpoints``` вызвается ещё один цикл, внутри которого вызывается миксин ```generate-breakpoint```, в который 
передаются ```$i``` – количество колонок, ```$value``` – ширина экрана и ```$name``` – название брейкпойнта.

Вот полный код файла ```mixins/_grid.scss``` с комментариями:

```scss
// превращает элемент в контейнер сетки
@mixin container {
  max-width: $container-width;
  margin: 0 auto;
  padding: 0 $container-padding;
}

// превращает элемент в строку сетки
@mixin row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$h-gutter / 2};
}

/*
  Превращает элемент в ячейку сетки размером в $cols колонок.
  Если при вызове примеси не передан ни один аргумент, к элементу будут применены правила, согласно которым элемент
  будет компоноваться как флекс-элемент и будет занимать пространство, равное занимаемому пространству соседними
  флекс-элментами
  Если при вызове примеси переданы оба аргумента и при этом тип первого аргумента $cols - число, а значение второго
  аргумента соответвствует одному из имен свойств глобального объекта $grid-breakpoints, то правило применяется только
  в медиазапросе, значение которого берется из этого второго аргумента. При этом в качестве значения второго аргумента
  должно использоваться одно из имен ключей глобального объекта $grid-breakpoints
  Если же передан только первый аргумент или значение второго аргумента не соответствует
  ни одному из имен ключей глобального объекта $grid-breakpoints, то элемент будет просто занимать количество ячеек,
  равное $cols
*/
@mixin col($cols: 'false', $breakpoint: 'false') {

  @if ($breakpoint != 'false' and map_has_key($grid-breakpoints, $breakpoint) and $cols != 'false' and type_of($cols) == number) {

    @media screen and(#{$media-query}-width: map-get($grid-breakpoints, $breakpoint)) {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
      flex: 0 0 auto;
      box-sizing: border-box;
      margin: 0 $h-gutter / 2 $v-gutter;
    }

  } @else if ($breakpoint == 'false' and $cols != 'false' and type_of($cols) == number) {
    width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  } @else {
    flex: 1 0 0%;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}

// рассчитывает ширину столбца в зависимости от переданного количества столбцов $cols
@function col-width($cols: 1) {
  @return calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
}

/*
  Генерирует "колоночные" классы вида .col-1, .col-2, .col-3 и т.д. исходя из глабальной переменной $columns - заданного
  количества колонок сетки
*/
@mixin generate-grid($cols: $columns) {
  @for $i from 1 through $cols {
    .col-#{$i} {
      width: col-width($i);
    }
  }
}

/*
  Генерирует "колоночный" класс сетки вида .col-tablet-8 и css-правила для него в медиазапросе исходя из $cols - числа
  столбцов, $screen-width - ширины экрана и $name - названия брейкпойнта, значение которого должно соответсвовать одному
  из имен ключей глобального объекта $grid-breakpoints
*/
@mixin generate-breakpoint($cols, $screen-width, $name) {
  .col-#{$name}-#{$cols} {
    @media screen and (#{$media-query}-width: $screen-width) {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter}) !important;
      flex: auto 0 0;
    }
  }
}

/*
  Генерирует "колоночные" классы сетки и css-правила для них в медиазапросе исходя из глобальной переменной
  $columns - заданного количества колонок сетки и глобальной переменной $grid-breakpoints - объекта с брейкпойнтами
*/
@mixin generate-grid-breakpoints($cols: $columns, $breakpoints: $grid-breakpoints) {
  @for $i from 1 through $cols {
    @each $name, $value in $breakpoints {
      @include generate-breakpoint($i, $value, $name);
    }
  }
}
```

А это полный код файла ```base.scss``` с учетом генерации классов в медиазапросах:

```scss
.container {
  @include container;
}

.row {
  @include row;
}

.col {
  @include col;
}

/*
  Генерация "колоночных" классов и правил для них исходя из глобальной переменной $columns - заданного количества
  столбцов сетки
*/
@for $i from 1 through $columns {
  .col-#{$i} {
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}

// генерация "колоночных" классов
@include generate-grid();

// генерация "колоночных" клоссов с медиазапросами
@include generate-grid-breakpoints();
```

Теперь мы можем строить сетку не только в sass, но и в html: 

```html
<div class="container">
  <div class="row">
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">1</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">2</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">3</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">4</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">5</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">6</div>
  </div>
</div>
```

```bash
пример результат
```

# Дальнейшие шаги

К настоящему моменту у нас реализован основной функционал нашей системы – мы можем строить адаптивную сетку с колонками 
разных размеров. Причём размеры колонок могут меняться в зависимости от размера экрана устройства, так как сетка 
поддерживает медиазапросы. Хотя данного функционала достаточно для построения гибкой адаптивной сетки, однако его 
недостаточно, чтобы считать такую сетку полноценной. Поэтому все дальнейшие шаги, которые мы реализуем, как раз и будут 
направлены на наращивание этого дополнительного функционала.

Вот список того, что мы реализуем дальше:
  - выравнивание колонок внутри ряда
  - направление расположения колонок
  - смещение колонок
  - изменение порядка расположения колонок
  - скрытие и отображение элементов внутри колонок
  - сброс внешних отступов у рядов и колонок
  
# Выравнивание колонок внутри ряда

Выравнивание колонок внутри ряда – это по сути то же самое, что и выравнивание флекс-элементов внутри флекс-контейнера. 
Ведь фактически колонки сетки и есть флекс-элементы внутри ряда сетки – флекс-контейнера. А как нам известно, для 
флекс-элементов существует два вида выравнивания – выравнивание вдоль главной оси и выравнивание вдоль поперечной оси. 
Лучше продемонстрировать это наглядно.

Выравнивание колонок вдоль главной оси:

Колонки распологаются вначале ряда:

```html
<div class="container">
  <div class="row justify-content-start">
  <div class="col-2">col</div>
  <div class="col-2">col</div>
  </div>
</div>
```

Колонки распологаются по центру ряда:

```html
<div class="container">
  <div class="row justify-content-center">
  <div class="col-2">col</div>
  <div class="col-2">col</div>
  </div>
</div>
```

Колонки распологаются в конце ряда:

```html
<div class="container">
  <div class="row justify-content-end">
  <div class="col-2">col</div>
  <div class="col-2">col</div>
  </div>
</div>
```
Колонки распологаются равномерно по ширине ряда. Аналог <span class='code'>justify-content: space-between</span>:

```html
<div class="container">
  <div class="row justify-content-space-between">
  <div class="col-2">col</div>
  <div class="col-2">col</div>
  </div>
</div>
```

Колонки распологаются равномерно по ширине ряда и имеют полуразмерное пространство. 
Аналог<span class='code'>justify-content: space-around</span>:
```html
<div class="container">
  <div class="row justify-content-space-around">
  <div class="col-2">col</div>
  <div class="col-2">col</div>
  </div>
</div>
```

Выравнивание колонок вдоль поперечной оси:

Колонки распологаются в начале ряда:

```html
<div class="container">
  <div class="row align-items-start">
  <div class="col">col</div>
  <div class="col">col</div>
  </div>
</div>
```

Колонки распологаются по центру ряда:

```html
<div class="container">
  <div class="row align-items-center">
  <div class="col">col</div>
  <div class="col">col</div>
  </div>
</div>
```

Колонки распологаются в конце ряда:

```html
<div class="container">
  <div class="row align-items-end">
  <div class="col">col</div>
  <div class="col">col</div>
  </div>
</div>
```

Колонки имеют "авто-размер", подстраиваясь под размер контейнера. Аналого <span class='code'>align-items: stretch</span>:

```html
<div class="container">
  <div class="row align-items-end">
  <div class="col">col</div>
  <div class="col">col</div>
  </div>
</div>
```

Выравнивание отдельно взятой колонки вдоль поперечной оси:

По центру ряда:

```html
<div class="container">
  <div class="row">
    <div class="col align-self-center"></div>
    <div class="col"></div>
  </div>
</div> 
```

Теперь давайте посмотрим, как реализовать такой функционал.

Для начала в директорию с миксинами <span class='code'>mixins</span> добавим новый файл <span class='code'>_alignment</span>, 
в котором и будет храниться код, отвечающий за выравнивание элементов. Первым делом добавим миксин, отвечающий за 
вырвнивание колонок вдоль главной оси: 

```scss
@mixin justify-content($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      justify-content: $align;
    }
  } @else {
    justify-content: $align;
  }
}
```

Миксин принимает на вход два параметра – <span class='code'>$align</span> и <span class='code'>$breakpoint</span>.
Параметр <span class='code'>$align</span> задаёт способ выравнивания колонок и может принимать одно из следующих значений: 
<span class='code'>flex-start</span>, <span class='code'>center</span>, <span class='code'>flex-end</span>, 
<span class='code'>space-between</span>, <span class='code'>space-around</span>. По умолчанию колонки располагаются 
вначале ряда.

Параметр <span class='code'>$breakpoint</span> определяет, будет ли выравнивание колонок применяться внутри медиазапроса. 
Если при вызове миксина ему будет передан второй аргумент и его значение будет соответствовать одному из имён ключей 
глобального массива <span class='code'>$grid-breakpoints</span>, то заданное выравнивание сработает в медиазапросе.
То есть, если мы вызовем миксин так:

```scss
.some {
  @include justify-content(flex-end);
}
```

тогда элемент будет расположен в конце ряда.

Если же мы вызовем миксин так:

```scss
.some {
  @include justify-content(flex-end, laptop);
}
```

тогда элемент будет расположен в конце ряда, когда размер вьюпорта будет равен 1024px и меньше.

Аналогично добавим миксин, отвечающий за выравнивание колонок вдоль поперечной оси:

```scss
@mixin align-items($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-items: $align;
    }
  } @else {
    align-items: $align;
  }
}
```

Этот миксин очень похож на предыдущий, за исключением того, что параметр <span class='code'>$align</span> задаёт 
выравнивание колонок вдоль поперечной оси и должен принимать сдедующие значения: <span class='code'>flex-start</span>, 
<span class='code'>flex-end</span>, <span class='code'>center</span>, <span class='code'>stretch</span>, 
<span class='code'>baseline</span>.

И наконец добавим последний миксин, отвечающий за выравнивание отдельно взятой колонки вдоль поперечной оси:

```scss
@mixin align-self($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-self: $align;
    }
  } @else {
    align-self: $align;
  }
}
```

Опять же, отличие данного миксина от двух предыдущих в том, что параметр <span class='code'>$align</span> задаёт 
выравнивание отдельно взятой колонки внутри ряда, но должен принимать те же значения, что и в предыдущем миксине: 
<span class='code'>flex-start</span>, <span class='code'>flex-end</span>, <span class='code'>center</span>, 
<span class='code'>stretch</span>, <span class='code'>baseline</span>.

Полный на данный момент код файла <span class='code'>mixins/_alignment.scss</span>:

```scss
@mixin justify-content($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      justify-content: $align;
    }
  } @else {
    justify-content: $align;
  }
}

@mixin align-items($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-items: $align;
    }
  } @else {
    align-items: $align;
  }
}

@mixin align-self($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-self: $align;
    }
  } @else {
    align-self: $align;
  }
}
```

Как мы помним, нам также нужно сгенерировать готовые предопределённые классы, которые позволят нам строить сетку 
исключительно в html-разметке. В директорию <span class='code'>partials</span> добавим файл <span class='code'>alignment.scss</span> 
и напишём в нём такой код:

```scss
.justify-content-start {
  @include justify-content(flex-start);
}

.justify-content-center {
  @include justify-content(center);
}

.justify-content-end {
  @include justify-content(flex-end);
}

.justify-content-space-between {
  @include justify-content(space-between);
}

.justify-content-space-around {
  @include justify-content(space-around);
}

.align-items-start {
  @include align-items(flex-start);
}

.align-items-center {
  @include align-items(center);
}

.align-items-end {
  @include align-items(flex-end);
}

.align-items-stretch {
  @include align-items(stretch);
}

.align-items-baseline {
  @include align-items(baseline);
}

.align-self-start {
  @include align-self(flex-start);
}

.align-self-center {
  @include align-self(center);
}

.align-self-end {
  @include align-self(flex-end);
}

.align-self-stretch {
  @include align-self(stretch);
}

.align-self-baseline {
  @include align-self(baseline);
}
```

В этих классах нет ничего особенного, они всего лишь подключают написанные выше миксины, тем самым добавляя правила 
выравнивания.

Как мы помним, вторым параметром наши миксины принимают имя брейкпойнта, при котором срабатывает выравнивание. Это значит, 
что наш код также должен генерировать классы выравнивания в медиазапросах. Чтобы было понятнее, я добавлю миксин, который 
при вызове генерирует "выравнивающие" классы в медиазапросах. Итак, в файл <span class='code'>mixins/_alignment</span> я 
добавляю следующий миксин:

```scss
@mixin generate-h-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $h-alignment-classes {
      .justify-content-#{$breakpoint-name}-#{$className} {
        @include justify-content($value, $breakpoint-name);
      }
    }
  }
}
```

Как видите, у нас появилась новая переменная <span class='code'>$h-alignment-classes</span>. Поэтому также добавим её в 
начало файла <span class='code'>mixins/_alignment</span>:

```scss
$h-alignment-classes: (
  start: flex-start,
  center: center,
  end: flex-end,
  between: space-between,
  around: space-around,
);
```
<span class='code'>$h-alignment-classes</span> – это массив, содержащий пары "ключ-значение", который нужен нам внутри 
миксина <span class='code'>generate-h-alignment-breakpoints</span>. Стоит более подробно рассмотреть этот миксин. Внутри 
миксина выполняется двойной цикл. Внешний цикл совершает проход по списку брейкпойнтов, хранящихся в глобальной переменной 
<span class='code'>$grid-breakpoints</span>. На каждой итерации этого цикла выполняется внутринний цикл, совершающий 
проход по списку <span class='code'>$h-alignment-classes</span>. В свою очередь на каждой итерации внутреннего цикла 
происходит формирование "выравнивающего" класса, внутри которого происходит подключение миксина, отвечающего за добавление 
правил, необходимых для выравнивания элемента вдоль основной оси. Причём все правила выравнивания формируются внутри 
директивы <span class='code'>@media</span>.

То есть в итоге вызов миксина сгенерирует классы вида: <span class='code'>.justify-content-desktop-start</span>, 
<span class='code'>.justify-content-laptop-center</span>, <span class='code'>.justify-content-phone-end</span> и т. д. 

Аналогично я добавлю ещё два миксина, отвечающих за генерирование классов, "выравнивающих" колонки вдоль поперечной 
оси, и классов, "выравнивающих" отдельно взятую колонку вдоль поперечной оси внутри ряда сетки:

```scss
@mixin generate-v-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $v-alignment-classes {
      .align-items-#{$breakpoint-name}-#{$className} {
        @include align-items($value, $breakpoint-name);
      }
    }
  }
}

@mixin generate-self-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $v-alignment-classes {
      .align-self-#{$breakpoint-name}-#{$className} {
        @include align-self($value, $breakpoint-name);
      }
    }
  }
}
```

И снова в начало файла добавлю дополнительную переменную:

```scss
$v-alignment-classes: (
  start: flex-start,
  center: center,
  end: flex-end,
  stretch: stretch,
  baseline: baseline
);
```

Эти два дополнительных миксина не нуждаются в подробном разборе, так как они по своему принципу действия аналогичны 
предыдущему миксину. Единственно, что стоит упомянуть, это то, что миксины генерируют классы, отвечающие за выравнивание 
элементов вдоль поперечной оси.

Теперь нам нужно вызвать эти миксины, чтобы сгенерировать все необходимые классы. Добавим вызов миксинов в файл 
<span class='code'>partials/alignment</span>:

```scss
// генерация "выравнивающих" классов вдоль главной оси внутри медиазапросов
@include generate-h-alignment-breakpoints();
// // генерация "выравнивающих" классов вдоль поперечной оси внутри медиазапросов
@include generate-v-alignment-breakpoints();
// // генерация "выравнивающих" классов вдоль главной оси внутри медиазапросов для отдельно взятой колонки
@include generate-self-alignment-breakpoints();
```

А теперь приведу полоный код с подробными комментариями.

mixins/_alignment.scss:

```scss
/* Выравнивание колонок внутри ряда вдоль основной и поперечной осей */

$h-alignment-classes: (
  start: flex-start,
  center: center,
  end: flex-end,
  between: space-between,
  around: space-around,
);

$v-alignment-classes: (
  start: flex-start,
  center: center,
  end: flex-end,
  stretch: stretch,
  baseline: baseline
);

/* ГОРИЗОНТАЛЬНОЕ ВЫРАВНИВАНИЕ */

/*
  Выкладывает колонки сетки в ряду согласно параметру $align, который должен принимать одно из следующих значений:
  flex-start, flex-end, center, space-between, space-around.
  Применяется к элементам ряда ($row) сетки.
  Если передан аргумент $breakpoint, выравнивание сработает в медиазапросе согласно значению этого аргумента.
  Значением аргумента должно быть одно из имен ключей глобального массива $grid-breakpoints.
*/
@mixin justify-content($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      justify-content: $align;
    }
  } @else {
    justify-content: $align;
  }
}

/* ВЕРТИКАЛЬНОЕ ВЫРАВНИВАНИЕ */

/*
  Выкладывает колонки сетки в ряду согласно параметру $align, который должен принимать одно из следующих значений:
  flex-start, flex-end, center, stretch, baseline.
  Применяется к элементам ряда ($row) сетки.
  Если передан аргумент $breakpoint, выравнивание сработает в медиазапросе согласно значению этого аргумента.
  Значением аргумента должно быть одно из имен ключей глобального массива $grid-breakpoints.
*/
@mixin align-items($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-items: $align;
    }
  } @else {
    align-items: $align;
  }
}

/*
  Выкладывает отдельно взятую колонку сетки в ряду согласно параметру $align, который должен принимать одно из следующих значений:
  flex-start, flex-end, center, stretch, baseline.
  Применяется к элементу отдельно взятой колонки ($col).
  Если передан аргумент $breakpoint, выравнивание сработает в медиазапросе согласно значению этого аргумента.
  Значением аргумента должно быть одно из имен ключей глобального массива $grid-breakpoints.
*/
@mixin align-self($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-self: $align;
    }
  } @else {
    align-self: $align;
  }
}

/*
  Генерирует классы выравнивания колонок сетки вдоль главной оси. Внутри класоов правила генерируются внутри директивы 
  @media, то есть внутри медиазапроса. Например: .justify-content-desktop-start, .justify-content-laptop-center и т.д. 
  Применяется к элементам строки ($row). Для формирования классов и брейкпоинтов в медиазапросах использует массивы 
  $h-alignment-classes и $grid-breakpoints.
*/
@mixin generate-h-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $h-alignment-classes {
      .justify-content-#{$breakpoint-name}-#{$className} {
        @include justify-content($value, $breakpoint-name);
      }
    }
  }
}

/*
  Генерирует классы выравнивания колонок сетки вдоль поперечной оси. Внутри класоов правила генерируются внутри директивы 
  @media, то есть внутри медиазапроса. Например: .align-items-desktop-start, .align-items-laptop-center и т.д. 
  Применяется к элементам строки ($row).
  Для формирования классов и брейкпойнтов в медиазапросах использует массивы $v-alignment-classes и $grid-breakpoints.
*/
@mixin generate-v-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $v-alignment-classes {
      .align-items-#{$breakpoint-name}-#{$className} {
        @include align-items($value, $breakpoint-name);
      }
    }
  }
}

/*
  Генерирует классы выравнивания отдельно взятой колонки сетки вдоль поперечной оси.
  Внутри класоов правила генерируются внутри директивы @media, то есть внутри медиазапроса.
  Например: .align-self-desktop-start, .align-self-laptop-center и т.д. Применяется к элементам колонки ($col).
  Для формирования классов и брейкпойнтов в медиазапросах использует массивы $v-alignment-classes и $grid-breakpoints.
*/
@mixin generate-self-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $v-alignment-classes {
      .align-self-#{$breakpoint-name}-#{$className} {
        @include align-self($value, $breakpoint-name);
      }
    }
  }
}
```

partials/alignment.scss:

```scss
.justify-content-start {
  @include justify-content(flex-start);
}

.justify-content-center {
  @include justify-content(center);
}

.justify-content-end {
  @include justify-content(flex-end);
}

.justify-content-space-between {
  @include justify-content(space-between);
}

.justify-content-space-around {
  @include justify-content(space-around);
}

.align-items-start {
  @include align-items(flex-start);
}

.align-items-center {
  @include align-items(center);
}

.align-items-end {
  @include align-items(flex-end);
}

.align-items-stretch {
  @include align-items(stretch);
}

.align-items-baseline {
  @include align-items(baseline);
}

.align-self-start {
  @include align-self(flex-start);
}

.align-self-center {
  @include align-self(center);
}

.align-self-end {
  @include align-self(flex-end);
}

.align-self-stretch {
  @include align-self(stretch);
}

.align-self-baseline {
  @include align-self(baseline);
}

// генерация "выравнивающих" классов вдоль главной оси внутри медиазапросов
@include generate-h-alignment-breakpoints();
// генерация "выравнивающих" классов вдоль поперечной оси внутри медиазапросов
@include generate-v-alignment-breakpoints();
// генерация "выравнивающих" классов вдоль главной оси внутри медиазапросов для отдельно взятой колонки
@include generate-self-alignment-breakpoints();
```

Теперь для выравнивания колонок мы можем воспользоваться как нашими миксинами, так и готовыми сгенерированными классами: 

```html
пример на html
```

```scss
пример на sass
```

В заключение этого раздела хотелось бы добавить ещё кое-что. Помните в начале я говорил о том, что пользователь сам волен 
выбрать, как ему строить сетку – добавлять готовые классы в разметку или же подключать готовые миксины в sass-файлах. 
Так вот, если пользователь решит использовать готовые миксины, то ему совсем необязательно генерировать большое 
количество предопределённых классов. Так вот, чтобы предотвратить генерацию классов, отвечающих за выравнивание колонок, 
мы обернём уже написанный код из файла <span class='code'>partials/alignment.scss</span> в условный блок так, как 
показано ниже:

```scss
@if index($partials, alignment) {

  .justify-content-start {
    @include justify-content(flex-start);
  }

  .justify-content-center {
    @include justify-content(center);
  }

  .justify-content-end {
    @include justify-content(flex-end);
  }

  .justify-content-space-between {
    @include justify-content(space-between);
  }

  .justify-content-space-around {
    @include justify-content(space-around);
  }

  .align-items-start {
    @include align-items(flex-start);
  }

  .align-items-center {
    @include align-items(center);
  }

  .align-items-end {
    @include align-items(flex-end);
  }

  .align-items-stretch {
    @include align-items(stretch);
  }

  .align-items-baseline {
    @include align-items(baseline);
  }

  .align-self-start {
    @include align-self(flex-start);
  }

  .align-self-center {
    @include align-self(center);
  }

  .align-self-end {
    @include align-self(flex-end);
  }

  .align-self-stretch {
    @include align-self(stretch);
  }

  .align-self-baseline {
    @include align-self(baseline);
  }

  // генерирация классов горизонтального выравнивания ячеек сетки в строке в медиазапросах
  @include generate-h-alignment-breakpoints();
  // генерация классов вертикального выравнивания ячеек сетки в столбце в медиазапросах
  @include generate-v-alignment-breakpoints();
  // генерация классов вертикального выравнивания отдельно взятой ячейки сетки в столбце в медиазапросах
  @include generate-self-alignment-breakpoints();
}
```

И переопределим нашу глобальную переменную <span class='code'>$partials</span> так, чтобы она больше не содержала элемент 
<span class='code'>alignment</span>.

Таким образом у нас не выполнится условие: 

```scss
@if index($partials, alignment) {
  // ...code
}
```

Напомню, что функция <span class='code'>index</span> вернёт позицию в списке для <span class='code'>alignment</span> или 
вернёт <span class='code'>null</span>, если элемент в списке не был найден. То есть найденная позиция интерпретируется как 
истинное значение условия, а <span class='code'>null</span> – как ложное.

Забегая вперёд скажу, что подобным образом мы реализуем остальные части нашей библиотеки, которые будут отвечать за 
генерацию предопределённых готовых классов. Для исключения тех или иных наборов классов мы можем переопределить переменную 
<span class='code'>$paritals</span>, хранящую список частей библиотеки, отвечающих за генерацию готовых классов. Мы 
можем вовсе отменить генерацию всех готовых классов, присвоив переменной <span class='code'>$partials</span> значение 
<span class='code'>false</span>, что значительно сократит скомпилированный css-файл нашей библиотеки.

# Направление расположения колонок

Направление колонок – это то, как будут выстраиваться колонки внутри ряда. Как и в случае с выравниванием колонок, лучше 
это продемонстрировать наглядно.

Направление по умолчанию – колонки располагаются слева направо вдоль основной оси:

```html
 пример
```

Колонки располагаются справа налево вдоль основной оси:

```html
пример
```

Колонки располагаются сверху вниз вдоль поперечной оси:

```html
пример
```

Колонки располагаются снизу вверх вдоль поперечной оси:
```html
пример
```

А теперь пошагово реализуем данный функционал. В директорию с нашими миксинами <span class='code'>mixins</span> я 
добавляю файл <span class='code'>_direction.scss</span>. Файл будет содержать миксин следующего содержания:

```scss
/* Направление расположения колонок в ряду */

/*
  Задает направление оси, вдоль которой укладываются колонки сетки в ряду.
  В качестве аргумента для первого параметра $direction должно быть передано одно
  из следующиех значений: row, row-reverse, column, column-reverse.
  Если вторым аргументом передано значение, соответствующее одному из имен ключей
  глобального массива $grid-breakpoints, правило будет применено в медиазапросе.
*/
@mixin direction($direction: row, $breakpoint: 'false') {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @if ($direction == row) {
      @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
        flex-direction: row;
      }
    } @else if ($direction == row-reverse) {
      @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
        flex-direction: row-reverse;
      }
    } @else if ($direction == column) {
      @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
        flex-direction: column;
      }
    } @else if ($direction == column-reverse) {
      @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
        flex-direction: column-reverse;
      }
    } @else {
      @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
        flex-direction: row;
      }
    }
  } @else {
    @if ($direction == row) {
      flex-direction: row;
    } @else if ($direction == row-reverse) {
      flex-direction: row-reverse;
    } @else if ($direction == column) {
      flex-direction: column;
    } @else if ($direction == column-reverse) {
      flex-direction: column-reverse;
    } @else {
      flex-direction: row;
    }
  }
}
```

Разберём код. На вход миксин принимает два параметра. Первый параметр отвечает за то, в каком направлении будут раполагаться 
колонки в ряду, и может принимать четыре значения: <span class='code'>row</span>, <span class='code'>row-reverse</span>, 
<span class='code'>column</span>, <span class='code'>column-reverse</span>. Если мы внимательно посмотрим на миксин, то 
увидим, что направление расположения колонок задаётся свойством <span class='code'>flex-direction</span>. Это неудивительно, 
ведь колонки – это флекс-элементы внутри флекс-контейнера – элемента ряда. Поэтому стоит добавить, что миксин имеет смысл 
вызывать лишь на элементе ряда сетки <span class='code'>row</span>. Второй параметр должен принимать одно из имён 
брейкпоинтов, которые хранятся в глобальном свойстве <span class='code'>$grid-breakpoints</span>: 
<span class='code'>desktop</span>, <span class='code'>laptop</span>, <span class='code'>laptop-md</span>, 
<span class='code'>tablet-landscape</span> и т.д.

Первой строкой внутри миксина условный оператор проверяет, содержит ли наш глобальный массив брейкпоинтов 
<span class='code'>$grid-breakpoints</span> элемент, имеющий ключ, имя которого соответствует аргументу, переданному в 
параметр <span class='code'>$breakpoint</span> при вызове миксина. Если условие выполняется, тогда все правила выравнивания 
оборачиваются директивой <span class='code'>@media</span>, то есть выполняются внутри медиазапроса. Если же условие не 
выполняется, тогда все правила выравнивания просто добавляются в селектор элемента.

Во второй строке и ниже по коду также присутствуют блоки условий, зависящие от первого параметра 
<span class='code'>$direction</span> и определяющие направление расположения колонок сетки.

И конечно, не забудем написать код, отвечающий за генерацию готовых "направляющих" классов. Для этого в директорию 
<span class='code'>partials</span> поместим файл <span class='code'>direction</span>. И напишем в нём такой код:

```scss
.direction-row {
  @include direction(row);
}

.direction-row-reverse {
  @include direction(row-reverse);
}

.direction-column {
  @include direction(column);
}

.direction-column-reverse {
  @include direction(column-reverse);
}
```

Этот код добавляет готовые "направляющие" классы, которыми мы можем воспользоваться "как есть", всего лишь прописав их 
в нашей html-разметке на нужных элементах страницы. Внутри себя селекторы классов всего лишь подключают написанные нами 
ранее миксины. Нам также необходимо добавить "направляющие" классы с медиазапросами. Для этого достаточно реализовать 
цикл, который пройдётся по массиву <span class='code'>$grid-breakpoints</span>, сгенерирует соответствующий имени 
брейкпоинта селектор класса и вызовет внутри него созданный нами ранее миксин 
<span class='code'>direction</span>, вторым параметром передав ему имена всех брейкпоинтов на каждом проходе цикла. Ведь 
как мы помним, если нашему миксину <span class='code'>direction</span> вторым параметром передать имя брейкпоинта, то 
заданные в результате правила будут обёрнуты в медиазапрос.

```scss
  // генерация "направляющих" классов в медиазапросах согласно заданным брейкпойнтам $grid-breakpoints
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    .direction-#{$breakpoint-name}-row {
      @include direction(row, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-row-reverse {
      @include direction(row-reverse, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-column {
      @include direction(column, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-column-reverse {
      @include direction(column-reverse, $breakpoint-name);
    }
  }
```

Этот код сгенерирует классы вида <span class='code'>direction-desktop-row</span>, <span class='code'>direction-laptop-column</span>,
<span class='code'>direction-phone-landscape-row-reverse</span> и т.д.

Полный код <span class='code'>partials/direction.scss</span>:

```scss
@if (index($partials, direction)) {

  .direction-row {
    @include direction(row);
  }

  .direction-row-reverse {
    @include direction(row-reverse);
  }

  .direction-column {
    @include direction(column);
  }

  .direction-column-reverse {
    @include direction(column-reverse);
  }

  // генерация "направляющих" классов в медиазапросах согласно заданным брейкпоинтам $grid-breakpoints
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    .direction-#{$breakpoint-name}-row {
      @include direction(row, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-row-reverse {
      @include direction(row-reverse, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-column {
      @include direction(column, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-column-reverse {
      @include direction(column-reverse, $breakpoint-name);
    }
  }
}
```

Теперь мы можем задавать направление колонок как в html, так и в sass:

```html
пример на html
```

```scss
пример на scss
```

Оба варианта дадут аналогичный результат:

```bash
результат работы кода
```

Примеры.

```bash
примеры
```

# Смещение колонок

Следующий модуль нашей библиотеки, который мы реализуем – это смещение колонок. Выражаясь более точно – это смещение 
колонки вправо или влево на расстояние, равное размеру одной или более колонок. Как всегда, лучше начать с примеров. 
В примерах ниже представлена сетка из двух рядов, первый из которых заполнен шестью элементами размером по две колонки 
каждый. Этот ряд нужен для наглядности того, на сколько колонок смещён элемент во втором ряду.

```html
примеры
```

А теперь реализуем это в нашем коде. В директорию <span class='code'>mixins</span> добавим файл <span class='code'>_offset.scss</span>.
Теперь поразмышляем, каким образом можно заставить колонку сместиться влево или вправо внутри ряда. Первое, что приходит 
на ум – это внешние отступы элемента. То есть, чтобы сместить колонку в ту или иную сторону, мы должны добавить ей левый 
или правый марджины. Очевидно также, что колонка может смещаться просто на всё свободное доступное пространство влево 
или вправо, реализуя таким образом эффект автосмещения. И также, как и в двух других написанных нами ранее модулях – 
выравнивания и направления, мы должны добавить возможность смещения колонок в медиазапросах. Начнём писать наш миксин. 

```scss
@mixin offset($direction: right, $offset: auto, $breakpoint: null) {
  //...
}
```

Наш миксин принимает на вход три параметра. Параметр <span class='code'>$direction</span> отвечает за направление смещения 
колонки и может принимать лишь два значения: <span class='code'>right</span> и <span class='code'>left</span> – вправо и 
влево соответственно. По умолчанию равен <span class='code'>right</span>.

Параметр <span class='code'>$offset</span> отвечает за расстояние, на которое может быть смещена 
колонка, и может принимать либо целое неотрицательное число, указывающее число колонок смещения, либо ключевое слово 
<span class='code'>auto</span>, указывающее, что колонка может быть смещена на всё доступное свободное пространство. 
По умолчанию равен <span class='code'>auto</span>.

Параметр <span class='code'>$breakpoint</span> отвечает за то, будут ли правила смещения колонки применяться внутри 
медиазапроса. Может принимать одно из имён брейкпоинтов, хранящихся в глобальном массиве <span class='code'>$grid-breakpoints</span>.
По умолчанию не передаётся.

```scss
@mixin offset($direction: right, $offset: auto, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    //...
  } else {
    //...
  }
}
```

В первой строке внутри миксина стоит условие, согласно которому, если при вызове было передано существующее имя брейкпоинта, 
то выполнится код из блока <span class='code'>@if</span>. Иначе будет выполнен код из блока <span class='code'>@else</span>.

```scss
@mixin offset($direction: right, $offset: auto, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      //...
    }
  } else {
    //...
  }
}
```

Если при вызове миксина было передано валидное имя брейкпоинта, то код из блока <span class='code'>@if</span> будет 
обёрнут в медиавыражение. Все дальнейшие условия, которые мы рассмотрим и которые находятся дальше по коду, будут 
одинаково присутствовать и внутри блока <span class='code'>@if</span>, и внутри блока <span class='code'>@else</span>.

```scss
@mixin offset($direction: right, $offset: auto, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      @if ($offset == auto) {
        @if ($direction == right) {
          margin-left: auto !important;
          margin-right: $h-gutter / 2 !important;
        } @else if ($direction == left) {
          margin-right: auto !important;
          margin-left: $h-gutter / 2 !important;
        } @else {
          margin-left: auto !important;
          margin-right: $h-gutter / 2 !important;
        }
      }
    }
  } else {
    @if ($offset == auto) {
      @if ($direction == right) {
        margin-left: auto !important;
        margin-right: $h-gutter / 2 !important;
      } @else if ($direction == left) {
        margin-right: auto !important;
        margin-left: $h-gutter / 2 !important;
      } @else {
        margin-left: auto !important;
        margin-right: $h-gutter / 2 !important;
      }
    }
  }
}
```

В третьей и семнадцатой строке прописано условие, по которому если для <span class='code'>$offset</span> передано значение 
<span class='code'>auto</span>, то возможны три варианта:
  - если значение параметра <span class='code'>$direction</span> равно <span class='code'>right</span>, то колонка 
    смещается на всё доступное пространство вправо
  - если значение параметра <span class='code'>$direction</span> <span class='code'>left</span>, то колонка смещается 
    на всё доступное пространство влево
  - и по умолчанию колонка всегда смещается вправо
  
Давайте ещё более расширим наш миксин:

```scss
@mixin offset($direction: right, $offset: auto, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      @if ($offset == auto) {
        @if ($direction == right) {
          margin-left: auto !important;
          margin-right: $h-gutter / 2 !important;
        } @else if ($direction == left) {
          margin-right: auto !important;
          margin-left: $h-gutter / 2 !important;
        } @else {
          margin-left: auto !important;
          margin-right: $h-gutter / 2 !important;
        }
      } @else if (type_of($offset) == number) {
        //...
      }
    }
  } else {
    @if ($offset == auto) {
      @if ($direction == right) {
        margin-left: auto !important;
        margin-right: $h-gutter / 2 !important;
      } @else if ($direction == left) {
        margin-right: auto !important;
        margin-left: $h-gutter / 2 !important;
      } @else {
        margin-left: auto !important;
        margin-right: $h-gutter / 2 !important;
      }
    } @else if (type_of($offset) == number) {
      //...
    }
  }
}
```

В четырнадцатой и тридцатой строках я добавил по условию, которые будут выполнены в том случае, если параметр 
<span class='code'>$offset</span> при вызове не будет равен <span class='code'>auto</span>, а будет являться числом. И в 
этом случае будет выполнен следующий код: 

```scss
@if ($offset > $columns) {
  $offset: $columns;
}

@if ($offset < 1) {
  $offset: 1;
}

@if ($direction == right) {
  margin-left: calc(100% / #{$columns} * #{$offset} + #{$h-gutter} / 2) !important;
} @else if ($direction == left) {
  margin-right: calc(100% / #{$columns} * #{$offset} + #{$h-gutter} / 2) !important;
}
```

Разберём его подробнее. Условие в первой строке защищает нас от ситуации, когда пользователь при подключении миксина 
пытается передать число, большее общего числа колонок сетки, хранящегося в глобальной переменной 
<span class='code'>$columns</span>. В этом случае параметр <span class='code'>$offset</span> автоматически будет равен 
этому общему числу колонок.

Условие в пятой строке защищает нас от ситуации, когда пользователь при подключении миксина попытается передать отрицатеьное 
число или ноль. В этом случае параметр <span class='code'>$offset</span> автоматически станет равным единице.

Условия в девятой и одиннадцатой строках зависят от значения параметра <span class='code'>$direction</span> и выполняют 
код, отвечающий за смещение элементов вправо и влево на указанное число колонок.

Итак полный код миксина:

```scss
  /* Смещение колонок */

/*
  Смещает колонку в ряду на $offset - целое число колонок, вправо - $direction: right или влево - $direction: left.
  Если в качестве второго аргумента передано значение auto, колонка смещается на свободное пространство в ту или иную
  сторону. Если значение аргумента $breakpoint соответствует одному из имен ключей глобального массива $grid-breakpoints,
  правила применяются в соответствующем медиазапросе.
*/
@mixin offset($direction: right, $offset: auto, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      @if ($offset == auto) {
        @if ($direction == right) {
          margin-left: auto !important;
          margin-right: $h-gutter / 2 !important;
        } @else if ($direction == left) {
          margin-right: auto !important;
          margin-left: $h-gutter / 2 !important;
        } @else {
          margin-left: auto !important;
          margin-right: $h-gutter / 2 !important;
        }
      } @else if (type_of($offset) == number) {
        @if ($offset > $columns) {
          $offset: $columns;
        }

        @if ($offset < 1) {
          $offset: 1;
        }

        @if ($direction == right) {
          margin-left: calc(100% / #{$columns} * #{$offset} + #{$h-gutter} / 2) !important;
        } @else if ($direction == left) {
          margin-right: calc(100% / #{$columns} * #{$offset} + #{$h-gutter} / 2) !important;
        }
      }
    }
  } @else {
    @if ($offset == auto) {
      @if ($direction == right) {
        margin-left: auto !important;
        margin-right: $h-gutter / 2 !important;
      } @else if ($direction == left) {
        margin-right: auto !important;
        margin-left: $h-gutter / 2 !important;
      } @else {
        margin-left: auto !important;
        margin-right: $h-gutter / 2 !important;
      }
    } @else if (type_of($offset == number)) {
      @if ($offset > $columns) {
        $offset: $columns;
      }

      @if ($offset < 1) {
        $offset: 1;
      }

      @if ($direction == right) {
        margin-left: calc(100% / #{$columns} * #{$offset} + #{$h-gutter} / 2) !important;
      } @else if ($direction == left) {
        margin-right: calc(100% / #{$columns} * #{$offset} + #{$h-gutter} / 2) !important;
      }
    }
  }

}
```

Теперь мы можем подключить наш миксин. Думаю излишне уточнять, что миксин нужно подключать к элементу колонки.

```html
<div class="container">
  <div class="row">
    <div class="col-3 offset-right-5"></div>
  </div>
</div>
```

```scss
.container {
  
  .col-3 {
    @include offset(right, 5);
  }
}
```

Приведённый выше код сместит колонку на пять колонок вправо.

Нам осталось написать модуль, ответственный за генерацию готовых классов смещения. В директорию <span class='code'>partials</span> 
добавим файла <span class='code'>offset.scss</span>.

partials/offset.scss:

Пишем цикл от одного до 12 – общего количества колонок:

```scss
@if (index($partials, offset)) {
  @for $i from 1 through $columns {
    //...
  }
}
```

Внутри цикла генерируются 12 селекторов "смещающих" классов вида <span class='code'>.offset-right-1</span>, 
<span class='code'>.offset-right-2</span>, <span class='code'>.offset-right-3</span> и т.д.:

```scss
@if (index($partials, offset)) {
  @for $i from 1 through $columns {
    .offset-right-#{$i} {
      //...
    }
  }
}
```

Внутри селектора на каждом проходе цикла подключается наш миксин <span class='code'>offset</span>, в который первым 
аргументом передаётся ключевое слово <span class='code'>right</span>, а вторым – число колонок смещения:

```scss
@if (index($partials, offset)) {
  @for $i from 1 through $columns {
    .offset-right-#{$i} {
      @include offset(right, $i);
    }
  }
}
```

Аналогичным образом генерируются и "левые смещающие" классы:

```scss
@if (index($partials, offset)) {
  @for $i from 1 through $columns {
    .offset-right-#{$i} {
      @include offset(right, $i);
    }
    
    .offset-left-#{$i} {
      @include offset(left, $i);
    }
  }
}
```

Ниже внутри этого же цикла генерируются "смещающие адаптивные" классы вида <span class='code'>offset-desktop-right-2</span>, 
<span class='code'>offset-laptop-left-4</span>, <span class='code'>offset-phone-landscape-6</span> и т.д. Это происходит 
внутри ещё одного цикла, который проходит по каждому элементу списка брейкпоинтов <span class='code'>$grid-breakpoints</span>, 
на каждой итерации генерирует селектор класса, внутри которого подключает наш миксин, но уже с передачей ему имени 
брейкпоинта третьим параметром.

```scss
@each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
  .offset-#{$breakpoint-name}-right-#{$i} {
    @include offset(right, $i, $breakpoint-name);
  }

  .offset-#{$breakpoint-name}-left-#{$i} {
    @include offset(left, $i, $breakpoint-name);
  }
}
```

Затем идёт формирование "автосмещающих" классов, не нуждающееся в подробном разборе:

```scss
.offset-right-auto {
  @include offset(right);
}

.offset-left-auto {
  @include offset(left);
}
```

И наконец формирование "автосмещающих адаптивных" классов:

```scss
@each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
  .offset-#{$breakpoint-name}-right-auto {
    @include offset(right, auto, $breakpoint-name);
  }

  .offset-#{$breakpoint-name}-left-auto {
    @include offset(left, auto, $breakpoint-name);
  }
}
```

В последнем примере осуществляется циклический проход по списку брейкпоинтов. На каждой итерации цикла генерируется 
селектор класса вида <span class='code'>.offset-desktop-right-auto</span>, <span class='code'>.offset-desktop-left-auto</span> 
и т.д. Внутри селектора происходит подключение миксина с передачей в него ключевого слова <span class='code'>right</span> 
или <span class='code'>left</span>, ключевого слов <span class='code'>auto</span> и имени брейкпоинта.

Полный код <span class='code'>partials/offset.scss</span>:

```scss
@if (index($partials, offset)) {

  // генерация "смещающих" классов соответственно числу колонок и соответственно числу колонок и медиазапросам
  @for $i from 1 through $columns {
    .offset-right-#{$i} {
      @include offset(right, $i);
    }

    .offset-left-#{$i} {
      @include offset(left, $i);
    }

    @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
      .offset-#{$breakpoint-name}-right-#{$i} {
        @include offset(right, $i, $breakpoint-name);
      }

      .offset-#{$breakpoint-name}-left-#{$i} {
        @include offset(left, $i, $breakpoint-name);
      }
    }
  }

  // генерация "автосмещающих" классов, правила в которых применяются в медиазапросах
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    .offset-#{$breakpoint-name}-right-auto {
      @include offset(right, auto, $breakpoint-name);
    }

    .offset-#{$breakpoint-name}-left-auto {
      @include offset(left, auto, $breakpoint-name);
    }
  }

  .offset-right-auto {
    @include offset(right);
  }

  .offset-left-auto {
    @include offset(left);
  }
}
```

Теперь мы можем осуществлять смещение колонок простым добавлением классов элементам в разметке:

```html
примеры
```

# Упорядочивание колонок

Следующий модуль нашей библиотеки, который мы реализуем – это упорядочивание колонок. Упорядочивание колонок – это задание 
колонкам порядка их следования внутри ряда. Примеры ниже демонстрируют изменение порядка расположения колонок.

Первая колонка расположена на втором месте:

```html
пример
```

Пятая колонка расположена на шестом месте:

```html
пример
```

Последняя колонка расположена на первом месте:

```html
пример
```

Первая колонка расположена на последнем месте:

```html
пример
```

А теперь добавим данный модуль в нашу библиотеку.

В директорию <span class='code'>mixins</span> добавим файл <span class='code'>_ordering.scss</span>, в котором начнём 
писать миксин, реализующий необходимый функционал.

Нам известно, что наши колонки являются флекс-элементами внутри флекс-контейнера ряда. Поэтому очевидно, что изменения 
порядка следования колонок мы можем добиться, устанавливая различные значения для их css-свойства 
<span class='code'>order</span>. Итак, миксин: 

```scss
@mixin order($order: 0, $breakpoint: null) {
  //...
}
``` 

На вход миксин принимает два параметра. Первый параметр <span class='code'>$order</span> – это целое число, определяющее 
порядок следования ячейки: чем меньше число, тем ближе к началу ряда будет расположена ячейка.

Если при вызове миксина в него будет передан второй аргумент $breakpoint, и при этом его значение будет соотвествовать
одному из имен ключей глобального массива $grid-breakpoints, то правило упорядочивания будет срабытывать лишь в медиазапросе.

```scss
@mixin order($order: 0, $breakpoint: null) {
  @if ($order > $columns) {
    $order: $columns;
  }
  
  @if ($order < 0) {
    $order: 0;
  }
  
  //...
}
```

В примере выше мы определили два условия, защищающие нас от случаев, когда пользователь первым аргументом передаст число, 
которое будет больше, чем общее число колонок сетки, либло меньше нуля. Это нужно потому, что ниже мы создадим ещё два 
миксина, один из которых служит для расположения колонки в начале ряда, а другой – в конце. И если мы не предусмотрим 
подобной защиты, то эти дополнительные миксины могут не работать должным образом. Итак, код из первого 
<span class='code'>@if</span> присваивает параметру <span class='code'>$order</span> значение 
<span class='code'>$columns</span> – общее число колонок, если при вызове миксина первым аргументом было передано число, 
превышающее <span class='code'>$columns</span>.

Код из второго <span class='code'>@if</span> устанавливает параметр <span class='code'>$order</span> в ноль, если при 
вызове миксина первым аргументом ему было передано отрицательное число.

```scss
@mixin order($order: 0, $breakpoint: null) {
  @if ($order > $columns) {
    $order: $columns;
  }

  @if ($order < 0) {
    $order: 0;
  }

  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      order: $order;
    }
  } @else {
    order: $order;
  }
}
```

В десятой строке мы имеем условие. Если при подключении миксина вторым аргументом ему было передано существующее имя 
брейкпоинта из списка <span class='code'>$grid-breakpoints</span>, то правило упорядочивания будет обёрнуто в медиазапрос.

Дальше добавим уже упомянутые ранне миксины, отвечающие за расположение колонок в начале и конце ряда:

```scss
@mixin order-first($breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      order: -1;
    }
  } @else {
    order: -1;
  }

}
```

Миксин <span class='code'>order-first</span> располагает колонку в начале ряда. Это достигается за счёт того, что свойству 
<span class='code'>order</span> элемента значение устанавливается в -1. Ну и единственный параметр 
<span class='code'>$breakpoint</span> определяет, будет ли правило обёрнуто в директиву <span class='code'>@media</span>.

Следующий миксин по принципу действия очень похож на предыдущий: 

```scss
@mixin order-last($breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      order: $columns + 1;
    }
  } @else {
    order: $columns + 1;
  }
}
```

Отличие в том, что свойство <span class='code'>order</span> элемента он устанавливает равным <span class='code'>$columns</span> 
плюс единица. То есть свойство <span class='code'>order</span> всегда будет на единицу больше общего числа колонок, что 
позволит гарантированно располагать колонку в конце ряда.

```html
примеры
```

Ну и по традиции добавим автоматическую генерацию "упорядочивающих" классов. Добавим в директорию <span class='code'>partials</span>
файл <span class='code'>ordering</span>:

```scss
@for $i from 0 through $columns {
  .order-#{$i} {
    order: #{$i};
  }
}
```

Этот цикл сгенерирует набор селекторов классов вида <span class='code'>.order-0</span>, <span class='code'>.order-1</span>, 
<span class='code'>.order-2</span> и т.д. и правил для них.

Далее нам нужно сгенерировать набор "адаптивных упорядочивающих" классов. Для этого добавим миксин следующего содержания: 

```scss
@each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
  @for $i from 0 through $columns {
    .order-#{$breakpoint-name}-#{$i} {
      @include order($i, $breakpoint-name);
    }
  }
}
```

Миксин в цикле проходится по списку наших глобальных брейкпоинтов, генерирует селекторы классов вида 
<span class='code'>order-desktop-3</span>, <span class='code'>order-tablet-8</span>, <span class='code'>order-laptop-md-2</span> 
и т.д. и внутри каждого селектора вызывает миксин <span class='code'>order</span>, передавая в него число порядка следования 
колонки и имя брейкпоинта, тем самым формируя правила для селектора.

Также создадим два готовых селектора класса, ответственных за расположение колонки в самом конце и самом начале ряда:

```scss
.order-first {
  @include order-first;
}

.order-last {
  @include order-last;
}
```

Полагаю, эти классы не нуждаются в подробном рассмотрении, так как они всего лишь подключают созданные нами ранее миксины, 
которые как раз и добавляют правила расположения колонок.

И конечно не забудем сгенерировать для этих классов их "адаптивные" варианты: 

```scss
@each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
  .order-#{$breakpoint-name}-first {
    @include order-first($breakpoint-name);
  }
}

@each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
  .order-#{$breakpoint-name}-last {
    @include order-last($breakpoint-name);
  }
}
```

Циклом мы проходимся по списку брейкпоинтов и формируем селекторы классов вида <span class='code'>.order-desktop-last</span>, 
<span class='code'>.order-desktop-first</span>, <span class='code'>.order-phone-sm-first</span>, 
<span class='code'>.order-laptop-last</span> и т.д. Внутри селекторов мы подключаем миксины <span class='code'>order-first</span> 
и <span class='code'>order-last</span> соответственно, в которые на каждом проходе цикла передаём имена наших брейкпоинтов.

Полный код файла <span class='code'>partials/ordering.scss</span> с подробными комментариями: 

```scss
@if (index($partials, ordering)) {

  /*
  Генерация "упорядочавающих" классов и правил для них: order-1, order-2, order-3 и т.д. согласно количеству заданных
  колонок $columns
  */
  @for $i from 0 through $columns {
    .order-#{$i} {
      order: #{$i};
    }
  }

  /*
    Генерация "упорядочивающих" классов в медиазапросах и правил для них: order-desktop-3, order-tablet-8, order-laptop-md-2 и т.д.
    согласно количеству заданных колонок $columns и значениям для медиазапросов $grid-breakpoints
  */
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @for $i from 0 through $columns {
      .order-#{$breakpoint-name}-#{$i} {
        @include order($i, $breakpoint-name);
      }
    }
  }

  /*
    Генерация "упорядочивающих" классов, перемещающих колонку в самое начало ряда, в медиазапросах: order-desktop-first,
    order-laptop-first, order-phone-sm-first и т.д. согласно заданным значениям в глобальном объекте $grid-breakpoints
  */
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    .order-#{$breakpoint-name}-first {
      @include order-first($breakpoint-name);
    }
  }

  /*
    Генерация "упорядочивающих" классов, перемещающих колонку в самый конец ряда, в медиазапросах: order-desktop-last,
    order-laptop-last, order-phone-sm-last и т.д. согласно заданным значениям в глобальном объекте $grid-breakpoints
  */
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    .order-#{$breakpoint-name}-last {
      @include order-last($breakpoint-name);
    }
  }

  .order-first {
    @include order-first;
  }

  .order-last {
    @include order-last;
  }
}
```

Теперь мы можем задавать порядок расположения колонок прямо в html-разметке: 

```html
примеры
```

# Скрытие и отображение элементов сетки

Следующий модуль, который мы реализуем – это скрытие и отображение элементов сетки. Для чего может пригодиться данный 
модуль? Например для организации мобильного меню на сайте – на малых разрешениях экрана меню будет скрыто, а на больших 
разрешениях будет отображаться как обычно. Конечно, можно скрывать не только элементы сетки, но и другие элементы на 
странице. Но стоит отметить, что касательно сетки имеет смысл скрывать лишь её элементы колонок. Пример ниже 
демонстрирует концепцию скрытия элементов. При уменьшении ширины вьюпорта до 960px и меньше, вторая и четвёртая колонка 
будут скрыты:

```html
<div class="container">
  <div class="example row">
    <div class="example__col col">1</div>
    <div class="example__col col hide-laptop-md">2</div>
    <div class="example__col col">3</div>
    <div class="example__col col hide-laptop-md">4</div>
  </div>
</div>
```

Давайте напишем миксин, реализующий данный функционал. В директорию <span class='code'>mixins</span> добавим файл 
<span class='code'>_hide.scss</span> и в нём напишем: 

```scss
@mixin hide($breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      display: none;
    }
  } @else {
    display: none;
  }
}
```

Миксин <span class='code'>hide</span> принимает на вход единственный параметр <span class='code'>$breakpoint</span>, по 
умолчанию равный <span class='code'>null</span>. Этот параметр отвечает за то, будут ли css-правила, добавляемые к 
подключающему миксин элемнту обёрнуты в директиву <span class='code'>@media</span>. Иными словами, будут ли правила 
применены внутри медиазапроса. И если при подключении миксина аргументом ему будет передано валидное имя брейкпоинта, то 
скрытие элемента сработает в соответствии со значением этого брейкпоинта. Напомню, что валидным именем будет являться 
любой из ключей глобального массива <span class='code'>$grid-breakpoints</span>. Если же при подключении миксина ему 
будет передано невалидное имя брейкпоинта, или же миксин будет вызван со значением по умолчанию, то правило скрытия будет 
просто применено к элементу.

Ниже приведены примеры, демонстрирующие миксин в действии. Для того, чтобы увидеть результат, поизменяйте размер окна 
браузера.

```html
примеры
```

И конечно, нам нужно реализовать генерацию готовых классов. Добавим в директорию <span class='code'>partials</span> файл 
<span class='code'>hide.scss</span>, в котором напишем:

```scss
@if (index($partials, hide)) {

  .hide {
    @include hide();
  }

  /*
    Генерация "скрывающих" классов в медиазапросах исходя из глобального массива $grid-breakpoints, содержащего значения 
    для медиазапросов
  */
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    .hide-#{$breakpoint-name} {
      @include hide($breakpoint-name);
    }
  }
}
```

Миксин генерирует селектор класса <span class='code'>.hide</span>, внутри которого подключается наш миксин. И так как 
миксин подключен без явной передачи ему аргумента, то внутрь селектора просто добавится css-правило, скрывающее элемент.

Затем в цикле по массиву <span class='code'>$grid-breakpoints</span> происходит генерирование селекторов классов вида 
<span class='code'>.hide-desktop</span>, <span class='code'>.hide-laptop</span>, <span class='code'>.hide-phone</span>, 
<span class='code'>.hide-tablet-landscape</span> и т.д., внутри которых наш миксин подключается уже с передачей ему 
имён брейкпоинтов.

Испытаем наши сгенерированные классы. Как и в предыдущих примерах, поизменяйте окно браузера.

```html
примеры
```

А теперь напишем код, позволяющий отображать скрытые ранее элементы. В директорию <span class='code'>mixins</span> 
добавим файл <span class='code'>_show.scss</span> и в нём напишем такой миксин: 

```scss
/* Отображение скрытых элементов */

/*
  Устанавливает свойство display у элемента, на котором вызван миксин. Если значение аргумента $breakpoint соответствует
  одному из имен ключей глобального массива $grid-breakpoints, правило будет применено в соответствующем медиазапросе
*/
@mixin show($display: initial, $breakpoint: null) {
  @if ($display == none) {
    $display: initial;
  }

  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      display: $display;
    }
  } @else {
    display: $display;
  }
}
```

По принципу дейтсвия этот миксин схож с миксином <span class='code'>hide</span>. Отличие в том, что он производит действие, 
обратное миксину <span class='code'>hide</span> – он отображает скрытые элементы. Это достигается за счёт установления 
свойства <span class='code'>display</span> элемента в значение <span class='code'>initial</span>, которое сбрасывает 
свойство в начальное значение. Например, если для элемента <span class='code'>div</span> было установлено 
<span class='code'>display: none</span>, то <span class='code'>display: initial</span> установит 
<span class='code'>display</span> в <span class='code'>block</span>. Для элемента <span class='code'>span</span> 
<span class='code'>display: initial</span> установит <span class='code'>display</span> в <span class='code'>inline</span>.

Обращу внимание на блок с условием в первой строке миксина. Это условие защищает нас от ситуации, когда пользователь 
библиотеки первым аргументом решит передать ключевое слово <span class='code'>none</span>. В таком случае параметр 
<span class='code'>$display</span> будет установлен в <span class='code'>initial</span>.

Ниже приведены примеры, демонстрирующие отображение скрытых элементов при изменении размера вьюпорта.

```html
примеры
```

Генерацию "отображающих" классов мы поместим в файл <span class='code'>show</span> в директории <span class='code'>partials</span>:

```scss
@if (index($partials, show)) {

  .show {
    @include show(initial);
  }

  /*
    Генерация "отображающих" классов в медиазапросах исходя из глобального объекта со значениями для медиазапросов
    $grid-breakpoints
  */
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    .show-#{$breakpoint-name} {
      @include show(initial, $breakpoint-name);
    }
  }
}
```

Думаю, что код не нуждается в особых пояснениях, потому как он аналогичен коду из предыдущего примера. Теперь мы можем 
добавлять наши сгенерированные классы в разметку:

```html
примеры
```
# Управление внешними отступами элементов

Последний модуль, который мы реализуем в нашей библиотеке, позволит нам управлять внешними отступами элементов сетки. 
Если быть точным, модуль даст нам возможность обнулять заданные элементам марджины. Ведь, как мы помним, по умолчанию 
колонки сетки имеют горизонтальные и нижний вертикальный отступы. Но может возникнуть ситуация, когда нам нужно обнулить 
только горизонтальные или только вертикальные марджины у одной колонки, или обнулить определённые марджины у колонок 
в одном из рядов сетки, или же вовсе обнулить отступы у всех колонок у одной сетки на странице, не касаясь колонок другой 
сетки. Некоторые из миксинов модуля, как мы увидим, будет возможно применять не только к колонкам сетки, но и при 
необходимости к любому элементу на странице. Итак, добавим в директорию <span class='code'>mixins</span> файл 
<span class='code'>_gutters.scss</span>. В него добавим первый миксин: 

```scss
// обнуляет внешние отступы элемента
@mixin no-gutters($breakpoint: null) {
  @if map_has_key($grid-breakpoints, $breakpoint) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      margin: 0 !important;
    }
  } @else {
    margin: 0 !important;
  }
}
```

Этот миксин просто обнуляет все внешние отступы элемента, на котором он вызван. Очевидно, что миксин может быть вызван 
на любом элементе страницы, а не только на элементах колонок нашей сетки. Миксин принимает параметр 
<span class='code'>$breakpoint</span>, равный по умолчанию <span class='code'>null</span> и определяющий, будет ли 
сброс отступов осуществляться внутри медиазапроса. Если аргумент при вызыове будет валидным именем одного из брейкпоинтов 
<span class='code'>$grid-breakpoints</span>, то привило будет применено в медиавыражении. Ниже представлен пример с сеткой, 
состоящей из одного ряда и нескольких колонок, у которых сброшены все внешние отступы:

```html
пример
```

Теперь добавим второй миксин, реализующий сброс только горизонтальных отступов у элементов:

```scss
// обнуляет внешние горизонтальные отступы элемента
@mixin no-h-gutters($breakpoint: null) {
  @if map_has_key($grid-breakpoints, $breakpoint) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      margin-right: 0 !important;
      margin-left: 0 !important;
    }
  } @else {
    margin-right: 0 !important;
    margin-left: 0 !important;
  }
}
```

Второй миксин аналогичен первому, за исключением того, что он обнуляет только горизонтальные отступы элемента, на котором 
он был вызван. Ниже представлен пример с сеткой, состоящей из одного ряда и нескольких колонок, у которых сброшены 
горизонтальные отступы:

```scss
пример
```

И третий миксин, сбрасывающий только вертикальные отступы элемента:

```scss
// обнуляет внешние вертикальные отступы элемента
@mixin no-v-gutters($breakpoint: null) {
  @if map_has_key($grid-breakpoints, $breakpoint) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      margin-top: 0 !important;
      margin-bottom: 0 !important;
    }
  } @else {
    margin-top: 0 !important;
    margin-bottom: 0 !important;
  }

}
```

Пример сброса вертикальных отступов:

```html
пример
```

А теперь добавим миксины, реализующие сборос отступов лишь у элементов колонок сетки:

```scss
// обнуляет внешние отступы колонок сетки
@mixin no-children-gutters($breakpoint: null) {
  @if map_has_key($grid-breakpoints, $breakpoint) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      > .col,
      > [class*='col-'] {
        margin: 0 !important;
      }
    }
  } @else {
    > .col,
    > [class*='col-'] {
      margin: 0 !important;
    }
  }
}

// обнуляет внешние горизонтальные отступы колонок сетки
@mixin no-children-h-gutters($breakpoint: null) {
  @if map_has_key($grid-breakpoints, $breakpoint) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      > .col,
      > [class*='col-'] {
        margin-left: 0 !important;
        margin-right: 0 !important;
      }
    }
  } @else {
    > .col,
    > [class*='col-'] {
      margin-left: 0 !important;
      margin-right: 0 !important;
    }
  }
}

// обнуляет внешние вертикальные отступы колонок сетки
@mixin no-children-v-gutters($breakpoint: null) {
  @if map_has_key($grid-breakpoints, $breakpoint) {
    @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      > .col,
      > [class*='col-'] {
        margin-bottom: 0 !important;
      }
    }
  } @else {
    > .col,
    > [class*='col-'] {
      margin-bottom: 0 !important;
    }
  }
}
```

Эти три миксина, как и предыдующие три, отвечают за сброс всех отступов, только горизонтальных отступов и только 
вертикальных отступов соответственно. Коренное отличие в том, что данные миксины обнуляют отступы только у элементов 
колонок, на что укзывают селекторы <span class='code'>> .col</span> и <span class='code'>> [class*='col-']</span>. 
Очевидно, что данные миксины имеет смысл подключать только к элементам ряда <span class='code'>row</span>, так как 
селекторы указывают на прямых потомков <span class='code'>.col</span>, <span class='code'>.col-1</span>, 
<span class='code'>.col-2</span>, <span class='code'>.col-3</span> и т.д.

Вот примеры сброса отступов у колонок:

```html
примеры
```

Теперь по аналогии с другими, написанными нами ранее модулями, реализуем генерирование классов, отвечающих за сброс 
отступов. В директорию <span class='code'>partials</span> добавим файл <span class='code'>gutters.scss</span> и начнём 
добавлять в него код:

```scss
.no-gutters {
  @include no-gutters;
}

.no-h-gutters {
  @include no-h-gutters;
}

.no-v-gutters {
  @include no-v-gutters;
}
```

Выше мы добавили три селектора класса, подключающие миксины, добавляющие селектору правила сброса всех марджинов, только 
горизонтальных марджинов и только вертикальных марджинов элемента соответственно.

Теперь добавим селекторы с миксинами, сбрасывающими отступы только у элементов колонок:

```scss
.no-children-gutters {
  @include no-children-gutters;
}

.no-children-h-gutters {
  @include no-children-h-gutters;
}

.no-children-v-gutters {
  @include no-children-v-gutters
}
```

И напоследок сгенерируем классы в медиазапросах:

```scss
@each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
  .no-gutters-#{$breakpoint-name} {
    @include no-gutters($breakpoint-name);
  }

  .no-h-gutters-#{$breakpoint-name} {
    @include no-h-gutters($breakpoint-name);
  }

  .no-v-gutters-#{$breakpoint-name} {
    @include no-v-gutters($breakpoint-name);
  }

  .no-children-gutters-#{$breakpoint-name} {
    @include no-children-gutters($breakpoint-name);
  }

  .no-children-h-gutters-#{$breakpoint-name} {
    @include no-children-h-gutters($breakpoint-name);
  }

  .no-children-v-gutters-#{$breakpoint-name} {
    @include no-children-v-gutters($breakpoint-name);
  }
}
```

Классы будут сгенерированы по тому же принципу, что и в других наших модулях: по списку определённых нами брейкпоинтов 
осуществляется проход цикла, на каждой итерации которого генерируются селекторы вида 
<span class='code'>.no-gutters-desktop</span>, <span class='code'>.no-h-gutters-laptop</span>,
<span class='code'>.no-children-v-gutters-phone-landscape</span> и т.д., внутри которых подключаются миксины, добавляющие 
селектору css-правила сброса марджинов.

Полный код файла <span class='code'>partials/gutters.scss</span>:

```scss
@if (index($partials, gutters)) {
  .no-gutters {
    @include no-gutters;
  }

  .no-h-gutters {
    @include no-h-gutters;
  }

  .no-v-gutters {
    @include no-v-gutters;
  }

  .no-children-gutters {
    @include no-children-gutters;
  }

  .no-children-h-gutters {
    @include no-children-h-gutters;
  }

  .no-children-v-gutters {
    @include no-children-v-gutters
  }

  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    .no-gutters-#{$breakpoint-name} {
      @include no-gutters($breakpoint-name);
    }

    .no-h-gutters-#{$breakpoint-name} {
      @include no-h-gutters($breakpoint-name);
    }

    .no-v-gutters-#{$breakpoint-name} {
      @include no-v-gutters($breakpoint-name);
    }

    .no-children-gutters-#{$breakpoint-name} {
      @include no-children-gutters($breakpoint-name);
    }

    .no-children-h-gutters-#{$breakpoint-name} {
      @include no-children-h-gutters($breakpoint-name);
    }

    .no-children-v-gutters-#{$breakpoint-name} {
      @include no-children-v-gutters($breakpoint-name);
    }
  }
}
```
А теперь на примерах посмотрим, как мы можем использовать наши новые готовые классы в нашей html-разметке: 