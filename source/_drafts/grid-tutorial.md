Эта статья – пошаговое исчерпывающее руководство по созданию собственной системы сеток с использованием препроцессора 
Sass. Подробно, шаг за шагом я покажу, как создать модульную, гибкую и легко кастомизируемую библиотеку, реализующую 
адаптивную сетку, наподобие той, что используется в фреймворках Bootstrap, Foundation, Bulma и многих других.
Библиотека позволит быстро и без особых усилий создавать адаптивные, отзывчивые макеты. Все примеры кода будут показаны 
с применением scss-синтаксиса. Итак, приступим!

# Два подхода при построении сетки
При построении сетки используются два основополагающих подхода:
 - Первый подход – в разметке страницы необходимым html-элементам прописываются нужные сеточные классы. Все детали реализации 
 скрыты в CSS:
```html
<div class="container">
  <div class="row">
    <div class="col-12 col-sm-6 col-md-3 col-xs-2"></div>
    <div class="col col-sm-4 col-md-3 col-xs-1"></div>
  </div>
</div> 
```
  
- Второй подход – все необходимые для реализации компонентов сетки правила прописываются в нужных селекторах в 
стилевом файле:

```css
.card {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -15px;
}
```

```html
<section class="card">
 <div class="card__header"></div>
 <div class="card__body"></div>
 <div class="card__footer"></div>
</section> 
```

Ни один из подходов не является более или менее правильным по отношению один к другому. У каждого имеются как свои плюсы, 
так и минусы. Какой из них выбрать – лишь вопрос ваших предпочтений. При первом подходе разметка засоряется большим 
количеством классов, которые к тому же приходится запоминать. При втором подходе усложняются стили. Мы в своей библиотеке
реализуем оба этих подхода – библиотека будет включать как богатый набор предопределенных классов, так и набор готовых 
sass/scss миксинов и функций, в совокупности реализующих адаптивную сетку.

# Элементы сетки
Каждая сетка должна включать элементы контейнера, рядов и колонок.

# Структура каталогов
```bash
grid/         - корневая директория библиотеки
  dist/       - скомпилированные css-файлы библиотеки
  sass/       - реализиция бибиотеки в sass-синтаксисе
  scss/       - реализация библиотеки в scss-синтаксисе
    mixins/   - миксины библиотеки, реализующие ядро
    partials/ - части библиотеки, реализующие генерацию предопределённых сеточных классов
    base.scss - начальная инициализация сетки
    grid.scss - главный файл, точка входа в библиотеку
```

```grid/``` – это основная директория, в которой будет храниться весь код нашей библиотеки

```dist/``` – директория содержит скомпилированные минифицированный и неминифицированный css-файлы библиотеки

```sass/``` – в этой директории будет храниться код библиотеки в sass-синтаксисе

```scss/``` – в этой директории будет храниться код библиотеки в scss-синтаксисе

```mixins/``` – директория с миксинами, реализующими основной функционал библиотеки

```partials/``` – директория хранит код, отвечающий за генерацию предопределённых готовых классов библиотеки

```base.scss/base.sass``` – этот файл содержит код, отвечающий за начальную инициализацию библиотеки. В нём задаются 
основные классы: контейнера, ряда, колонки, а также генерируются "колоночные" классы и классы в медиазапросах.

```grid.scss/grid.sass``` – это так называемая точка входа в библиотеку. Именно этот файл будет указан в поле ```main``` 
в файле ```package.json```. Файл будет содержать все глобальные переменные библиотеки, а также подключать все необходимые 
части библиотеки.

# Глобальные переменные

Для того чтобы пользователи нашей библиотеки имели возможность настраивать и кастомизировать сетку, необходимо определить 
переменные, которые можно будет переопределить и задать им свои значения. Все переменные по умолчанию и внутренние, 
необходимые для нужд библиотеки переменные будут находиться в основном файле ```grid.scss```:

```scss
$container-width: 1140px !default; // ширина контейнера
$container-padding: 15px !default; // внутренние отступы контейнера
$h-gutter: 30px !default; // расстояние между ячейками сетки по горизонтали
$v-gutter: $h-gutter !default; // расстояние между ячейками сетки по вертикали
$columns: 12 !default; // количество колонок сетки
// флаг, указывающий, какой подход будет использован при формиравнии медиазапросов - mobile first или desktop first
$mobile-first: false !default;

// возвращает ключевое слово min или max, которое будет использовано при формировании всех медиазапросов библиотеки -
// min-width или max-width
@function query-direction() {
  @if($mobile-first) {
    @return min;
  } @else {
    @return max;
  }
}

$media-query: query-direction(); // min или max

$grid-breakpoints: (
  desktop: 1280px,
  laptop: 1024px,
  laptop-md: 960px,
  tablet-landscape: 768px,
  phone-landscape: 640px,
  phone: 480px,
  phone-md: 360px,
  phone-sm: 320px
) !default;

// для уменьшения конечного css-файла можно закомментировать ненужные части ( partials )
$partials: (
  alignment,
  direction,
  hide,
  offset,
  ordering,
  show,
  gutters
) !default;

@import 'mixins/mixins';
@import 'partials/alignment';
@import 'partials/ordering';
@import 'partials/direction';
@import 'partials/hide';
@import 'partials/show';
@import 'partials/offset';
@import 'partials/gutters.scss';
@import 'base';
```

Прежде чем подробно рассмотреть каждую переменную, хотелось бы сказать, что почти все объявления переменных, 
как вы могли заметить, оканчиваются флагом ```!default```. Размещение этого флага в конце объявления переменной даёт нам 
следующий эффект – если переменная уже имеет присвоение, она не будет переназначена. Что в свою очередь даёт нам возможность 
переопределять переменные библиотеки перед её импортом в пользовательский код. Чтобы было понятен смысл сказанного, приведу 
пример:

В файл ```index.scss``` импортируем файл ```grid.scss```:

```scss
@import "grid.scss";
```
Здесь мы просто импортировали файл библиотеки с объявленными в нём переменными, никак их не изменив.

```scss
$container-width: 1600px;
$container-padding: 20px;

@import "grid.scss";
```
Здесь же мы сначала присвоили значения двум переменным и только потом импортировали файл библиотеки. А так как обе эти 
переменные внутри ```grid.scss``` объявлены с флагом ```!default```, значит они примут те значения, которые мы им задали 
выше. Иными словами мы переопределили значения по умолчанию. Подробнее про директиву ```!default``` можно почитать в 
официальной [документации](https://sass-lang.com). А теперь подробнее рассмотрим наши переменные.
- ```container-width``` – максимальная ширина контейнера сетки.
- ```container-padding``` – внутренние горизонтальные отступы контейнера (paddings).
- ```h-gutter``` – внешние горизонтальные отступы между колонками или ячейками сетки (margins).
- ```v-gutter``` – внешние вертикальные отступы между колонками или ячейками сетки (margins).
- ```columns``` – количество колонок, на которые будет разбита наша сетка. По умолчанию она будет состоять из классических 
двенадцати колонок.
- ```mobile-first``` - булева переменная, используемая внутренней служебной функцией ```query-direction```
- ```query-direction``` - утилитарная внутрення функция, которая возвращает одно из значений - min или max, в зависимости 
от значения переменной ```mobil-first```.
- ```media-query``` - это динамическая переменная, которая всегда будет содержать значение, возвращаемое вышеописанной 
функцией - min или max. Эта переменная будет использоваться при генерации всех медиазапросов библиотеки и определять, 
какой подход будет применяться при формировании этих медиазапросов - mobile-first или desktop-first:

  При ```$mobile-first: true``` система будет генерировать такой код:
  ```scss
    @media (min-width: 960px) {
      //content
    }
  ```
  
  При ```$mobile-first: false``` такой:
  ```scss
    @media (max-width: 960px) {
      //content
    }
  ```
  Далее по ходу статьи я ещё остановлюсь более подробно на механизме формирования медиазапросов.
  
- ```grid-breakpoints``` - массив пар ключ-значение, описывающий набор контрольных точек сетки. По умолчанию наша сетка 
будет включать восемь контрольных точек. Но мы, так же, как и другие переменные, можем её переопределить, задав более 
распространённые класические названия и значения контрольных точек:
   ```sass
   $grid-breakpoints: (
    lg: 1140px,
    md: 960px,
    sm: 768px,
    xs: 500px
   );
   ```
 - ```$partials``` - список тех частей библиотеки, код в которых отвечает за генерирование всех классов сетки. Эти классы 
 необходимы, если мы применим описанный выше первый подход для построения сетки - добавление классов в разметку документа. 
 Если для построения сетки мы будем использовать миксины, то нет необходимости в генерировании большого количества 
 классов, и поэтому мы можем переопределить список, установив его значение в ```false```. Это значительно сократит 
 скомпилированный css-файл библиотеки.
 - Далее в ```grid.scss``` идёт импорт миксинов, частей и основного файла, инициализирующего библиотеку.

# Создание контейнера сетки
Сетка должна содержать контейнер, определяющий её максимальную ширину, внешние и внутренние отступы. Все сущности сетки 
будут создаваться при помощи миксинов. Создадим контейнер, поместив следующий код в файл ```mixins/_grid.scss```:

```scss
@mixin container {
  max-width: $container-width;
  margin: 0 auto;
  padding: 0 $container-padding;
}
```
Мы задаём нашему контейнеру максимальную ширину и внешние отступы для его центрирования. Также мы задаём контейнеру 
внутренние отступы, чтобы контент в нём не прилипал к краям браузера. Размеры для ширины и отступов мы взяли из глобальных 
переменных, определённых в ```grid.scss```. Теперь мы можем вызвать этот миксин на любом элементе в нашем sass-коде:

```scss
.wrapper {
  @include container();
}
```
Таким образом наш элемент ```wrapper``` теперь является контейнером сетки. Но нам также нужен готовый предопределённый 
css-класс, реализующий этот же функционал, чтобы мы просто могли прописать его в нашей разметке, не заморачиваясь со стилями. 
Для этого в файл ```base.scss``` добавим следующий код:

```scss
.container {
  @include container;
}
```
Теперь мы можем прописать этот класс в html-разметке нужному нам элементу:

```html
<div class="container"></div> 
```

Наш div также станет контейнером сетки. Подобным образом мы создадим другие наши элементы сетки и её функционал, тем 
самым реализовав оба подхода - "сетка в html" и "сетка в css".

# Создание ряда сетки

Наряду с контейнером сетка обязательно должна включать такую сущность, как ряд (или строка). Ряд является в свою очередь 
контейнером для колонок (или ячеек) сетки. Ряд задаёт позиционирование и расположение колонок внутри себя. Сетка может 
содержать один и более элементов ряда. В ```mixins/_grid.scss``` добавим миксин, создающий ряд:

```scss
@mixin row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$h-gutter / 2};
}
```

И не забудем в ```base.scss``` добавить селектор класса для ряда:

```scss
.row {
  @include row;
}
```

Для элемента ряда мы устанавливаем значение ```display: flex```: это нужно для того, чтобы поставить колонки в ряд. Правило 
```flex-wrap: wrap``` мы устанавливаем для того, чтобы, когда для колонок задан размер, они не теснились на одной строке, 
а переносились на следующую. И наконец внешним горизонтальным отступам мы задаём отрицательное значение. Для чего это 
нужно? Как было показано выше, в файле ```grid.scss``` мы определили переменную ```$h-gutter``` - расстояние между 
колонками будущей сетки по горизонтали. По умолчанию оно равно 30px. Забегая вперёд скажу, что для элементов колонок мы 
установим внешние горизонтальные отступы (margins), равные ```$h-gutter / 2```, так как марджины у флекс-элементов, 
каковыми являются наши колонки, внутри флекс-контейнера не схлопываются; ```$h-gutter / 2``` даст нам 15px. То есть по 
15px внешнего отступа справа и слева у каждой колонки. Проблема в том, что элементы колонок своими марджинами будут 
отталкиваться не только друг от друга, но и от правого и левого краёв контейнера, что приведёт к появлению у него 
ненужных зон. Это продемонстрировано на изображении ниже:

 ```html
картинка, демонстрирующая лишние пустые зоны по краям контейнера
```
Возвращаясь к вопросу, для чего элементу ряда устанавливать отрицательные марджины. Дело в том, что это создаст эффект 
того, что дочерние элементы колонок как бы провалятся за границы родительского элемента строки. Это легко увидеть, задав 
элементу строки фоновый цвет:

```html
картинка или сниппет
```

Таким образом первая и последняя колонка в каждом ряду будут вплотную прилегать к краям контейнера. Правило 
```margin: 0 -#{$h-gutter / 2};``` буквально означает – вертикальные марджины установить в значение ноль, а горизонтальным 
присвоить значение, равное половине значения определённой нами переменной ```$h-gutter```, то есть 15px; затем 
инвертировать полученное значение, поставив перед ним знак "–". Знак "#" в Sass означает интерполяцию переменной, подробнее 
о которой можно почитать в [документации](https://sass-lang.com/).

# Создание колонки сетки

Последняя неотъемлемая сущность сетки - это колонка. Колонки располагаются внутри рядов. Элемент ряда может содержать 
один и более элементов колонок. В ```mixins/_grid.scss``` добавим миксин, создающий колонку:

```scss
mixin col {
  flex: 1 0 0%;
  box-sizing: border-box;
  margin: 0 $h-gutter / 2 $v-gutter;
}
```

Здесь следует более подробно остановиться на каждом правиле селектора колонки. Правило в первой строке задаёт поведение
элемента колонки как flex-элемента. Как мы знаем свойство  ```flex``` - это сокрщённая запись для трёх свойств: 
```flex-grow```, ```flex-shrink``` и ```flex-basis```. Для ```flex-grow``` мы выставили значение в 1 для того, 
чтобы колонки были текучими и занимали всё свободное доступное пространство, не сжимаясь под содержащийся в них контент, 
и чтобы при этом они занимали равные доли свободного пространства. Для ```flex-shrink``` мы установили значение в 0, 
тем самым переопределив значение по умолчанию, равное 1. Это также сделано для того, чтобы колонки занимали равное 
пространство, не сжимаясь. И с этой же целью для свойства ```flex-basis``` мы выставили значение в 0%, которое по 
умолчанию равно auto, что также может привести к сжатию колонки до содержащегося в них контента.

Во второй строке свойству ```box-sizing``` мы присвоили значеиние ```border-box```, что позволит рассчитать значение 
ширины колонки, включив в неё (ширину) размеры ```padding```, ```margin``` и ```border```. То есть размеры внутренних и 
внешних отступов элемента колонки, а таже размер рамки будут не добавляться к значению ширины, а рассчитываться внутрь 
элемента.

Третьей строкой мы задали внешние горизонтальные и вертикальные отступы, значение которых, как мы помним, равно глобальным 
переменным ```$h-gutter``` и ```$v-gutter``` соответственно.

Не забываем в ```base.scss``` добавить селектор для колонки:
  ```scss
  .col {
    @include col;
  }
  ```
# Начальная версия сетки
Ниже представлен полный код, который мы написали к этому моменту:

```base.scss```:

```scss
.container {
  @include container;
}

.row {
  @include row;
}

.col {
  @include col;
}
```

```mixins/_grid.scss```:

```scss
@mixin container {
  max-width: $container-width;
  margin: 0 auto;
  padding: 0 $container-padding;
}

@mixin row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$h-gutter / 2};
}

mixin col {
  flex: 1 0 0%;
  box-sizing: border-box;
  margin: 0 $h-gutter / 2 $v-gutter;
}
```

И уже на данном этапе мы можем построить сетку:

Прописав нужные классы в html-разметке:

```scss
сниппет
```

```bash
пример сетки
```

Подключив нужные миксины в селекторах в нашем sass-файле:

```scss
.wrap {
  @include container;
}

.header,
.main,
.footer {
  @include row;
}

.sidebar,
.content,
.logo,
.nav,
.login,
.about,
.email {
  @include col;
}
```
В первом примере сетка состоит из трёх рядов по четыре колонки в каждом, во втором – из трёх рядов по три колонки.

В обоих примерах мы видим, что колонки в одном ряду имеют одинаковую ширину. Причём это поведение не зависит от количества 
колонок. Сколько бы колонок не находилось в одном ряду, все они будут иметь одинаковую ширину.

```html
пример
```
Теперь нам нужно реализовать возможность указывать количество колонок, которое будет занимать тот или иной элемент, что 
позволит нам рассчитать его ширину. Дополним миксин колонки в файле ```mixins/_grid.scss```:

```scss
@mixin col($cols: 'false') {
  @if ($cols != 'false' and type_of($cols) == number) {
    @if ($cols > $columns) $cols: $columns;
  
    width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  } @else {
    flex: 1 0 0%;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}
```
Теперь миксин имеет параметр ```$cols``` со значением по умолчанию – количество колонок, занимаемое элементом. Внутри 
миксина мы проверяем, что значение переданного аргумента – не false и что тип аргумента – число. Далее мы проверяем, что 
значение аргумента не больше значения переменной ```$columns```: как мы помним – это глобальная переменная, хранящая 
количество колонок сетки. Если при передаче аргумента мы укажем число большее, чем установленное количество колонок, 
значение переменной ```$cols``` просто будет равно этому количеству.

Затем мы указываем ширину колонки, которая рассчитывается по такой нехитрой логике: если принять, что ширина ряда равна 
100%, а сетка содержит двенадать колонок, то ширина одной колонки равна 100% / 12 = 8,333333333333333%. Дальше значение 
ширины одной колонки мы умножаем на ```$cols``` – количество необходимых нам колонок. Также не забываем вычесть значение 
горизонтальных марджинов ```$h-gutter```. Таким образом мы получаем ширину элемента, равную указанному числу колонок. 
Что касается свойства  ```flex```: если при вызове миксина мы указываем количество колонок, то свойству ```flex-grow``` 
мы должны присвоить значение 0, а свойству ```flex-basis``` – значение ```auto```. Это нужно для того, чтобы ширина 
колонок рассчитывалась не автоматически, а согласно числу переданных колонок. Подкрепим теорию практикой, чтобы увидеть 
результат наших вычислений в действии. Перепишем наш старый пример, содержащий элементы logo, nav, login и другие. Сделаем 
так, чтобы элементы logo, sidebar, login и email занимали по три колонки, а элементы nav, content и about – по шесть:

```scss
.wrap {
  @include container;
}

.header,
.main,
.footer {
  @include row;
}

.logo,
.sidebar,
.login,
.email {
  @include col(3);
}

.nav,
.content,
.about {
  @include col(6);
}
```

```bash
пример
```

Теперь для элементов logo, sidebar, login и email установим ширину в две колонки, а для nav, content и about – в восемь:

```scss
.wrap {
  @include container;
}

.header,
.main,
.footer {
  @include row;
}

.logo,
.sidebar,
.login,
.email {
  @include col(2);
}

.nav,
.content,
.about {
  @include col(5);
}
```

```bash
пример
```

# Генерация готовых колоночных классов

Мы усовершенствовали миксин, создающий колонки. Но нам также нужно добавить код, генерирующий готовые колоночные классы, 
которые мы сможем использовать в нашей разметке. В <span class='code'>base.scss</span> напишем:

```scss
@for $i from 1 through $columns {
  .col-#{$i} {
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}
```

Здесь мы в цикле от одного до ```$columns``` генерируем колоночные классы и правила для них. Как мы помним ```$columns``` 
– это глобальная переменная, содержащая установленное число колонок сетки. Таким образом у нас сгенерируются классы вида 
col-1, col-2, col-3 и т. д. Этот код описывает общие правила для всех колоночных классов. Но также для разных классов
мы должны задать разную ширину. Ведь очевидно, что элемент, занимающий допустим шесть колонок будет шире элемента, 
занимающего четыре колонки. Для этого в ```mixins/_grid.scss``` я добавлю такой миксин:

```scss
@mixin generate-grid($cols: $columns) {
  @for $i from 1 through $cols {
    .col-#{$i} {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    }
  }
}
```

Здесь нет ничего сложного. На вход миксин принимает общее количество колонок сетки и в цикле генерирует колоночные классы 
и правило, задающее ширину для каждого такого класса.

Для упрощения миксина ```generate-grid``` рассчет ширины колонки я решил вынести в отдельную функцию. Хотя это и 
необязательно. В ```mixins/_grid.scss``` добавим:

```scss
@function col-width($cols: 1) {
  @return calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
}
```

И перепишем миксин:

```scss
@mixin generate-grid($cols: $columns) {
  @for $i from 1 through $cols {
    .col-#{$i} {
      width: col-width($i);
    }
  }
}
```

Чтобы сгенерировать колоночные классы и правила для них, нужно вызвать наш миксин. Вызов миксина добавим в ```base.scss```: 

```scss
@include generate-grid();
```
Полный код ```base.scss``` на данный момент:

```scss
.container {
  @include container;
}

.row {
  @include row;
}

.col {
  @include col;
}

/*
  Генерация "колоночных" классов и правил для них исходя из глобальной переменной $columns - заданного количества
  столбцов сетки
*/
@for $i from 1 through $columns {
  .col-#{$i} {
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}

// генерация "колоночных" классов
@include generate-grid();
```

Полный код ```mixins/_grid.scss```:

```scss
// превращает элемент в контейнер сетки
@mixin container {
  max-width: $container-width;
  margin: 0 auto;
  padding: 0 $container-padding;
}

// превращает элемент в строку сетки
@mixin row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$h-gutter / 2};
}

// превращает элемент в колонку сетки
@mixin col($cols: 'false') {
  @if ($cols != 'false' and type_of($cols) == number) {
    @if ($cols > $columns) $cols: $columns;
 
    width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  } @else {
    flex: 1 0 0%;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}

// рассчитывает ширину столбца в зависимости от переданного количества столбцов $cols
@function col-width($cols: 1) {
  @return calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
}

/*
  Генерирует "колоночные" классы вида .col-1, .col-2, .col-3 и т.д. исходя из глабальной переменной $columns - заданного
  количества колонок сетки
*/
@mixin generate-grid($cols: $columns) {
  @for $i from 1 through $cols {
    .col-#{$i} {
      width: col-width($i);
    }
  }
}
```
Теперь мы можем строить нашу сетку, лишь добавляя в разметку необходимые классы:

```html
<div class="container">
  <div class="row">
    <div class="col-6"></div>
    <div class="col-6"></div>
  </div>
  
  <div class="row">
    <div class="col-2"></div>
    <div class="col-4"></div>
    <div class="col-5"></div>
    <div class="col-1"></div>
  </div>
</div> 
```

# Колоночные классы в медиазапросах

На данный момент в нашем коде уже реализовано создание контейнера сетки, рядов, колонок одинаковой и заданной ширины. 
Также для всего этого мы реализовали генерацию предопределённых готовых классов. Заверщающий из основных шагов построения 
сеточной системы – это добавление медиазапросов. Хотелось бы акцентировать внимание на том, что это именно последний из 
основных шагов, после реализации которого мы получим в принципе готовую и работоспособную библиотеку. А все шаги, которые 
мы будем рассматривать далее, будут добавлять дополнительный важный, но не необходимый функционал. Итак, реализуем наш 
следующий шаг – добавим возможность генерации колонок в медиазапросах. Для начала дополним миксин, создающий колонку:

```scss
@mixin col($cols: 'false', $breakpoint: 'false') {

  @if ($breakpoint != 'false' and map_has_key($grid-breakpoints, $breakpoint) and $cols != 'false' and type_of($cols) == number) {

    @media screen and(#{$media-query}-width: map-get($grid-breakpoints, $breakpoint)) {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
      flex: 0 0 auto;
      box-sizing: border-box;
      margin: 0 $h-gutter / 2 $v-gutter;
    }

  } @else if ($breakpoint == 'false' and $cols != 'false' and type_of($cols) == number) {
    width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  } @else {
    flex: 1 0 0%;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}
```

Как мы видим, у миксина ```col``` появился дополнительный параметр ```$breakpoint```, по умолчанию равный ```false```. 
Внутрь миксина я добавил условие, которое гласит, что если при вызове миксина значение ```$breakpoint``` не равно
```false```, а равно одному из имён ключей глобального массива ```$grid-breakpoints``` (desktop, laptop, tablet-landscape, 
phone и т.д.), то css-правила для элемента, на котором был вызван миксин, сработают в медиазапросе. Иными словами, если 
мы вызовем миксин таким образом:

```scss
@include col(8, laptop);
```

то получим следующий сгенерированный css-код:

```css
@media screen and (max-width: 1024px) {
  width: calc(100% / 12 * 8 - 30px);
  flex: 0 0 auto;
  box-sizing: border-box;
  margin: 0 15px 15px;
}
```

Здесь стоит отметить, что в правиле ```@media``` значение ширины, как мы видим, было задано через ```max-width```. Это 
поведение по умолчанию и зависит, как я упоминал вначале, от глобальной переменной ```$mobile-first``` в файле 
```grid.scss```. Если перед импортом библиотеки переопределить переменную и присвоить ей значение ```true```:

```scss
$mobile-first: true;

@import "grid.scss";
```

то получим следующий код:

```css
@media screen and (min-width: 1024px) {
  width: calc(100% / 12 * 8 - 30px);
  flex: 0 0 auto;
  box-sizing: border-box;
  margin: 0 15px 15px;
}
```

Пришло время испытать наш миксин на практике. Предположим, что мне нужно построить сетку, состоящую из шести элементов, 
расположенных в ряд. Размер каждого элемента равен двум колонкам. При размере вьюпорта 1024px и меньше, размер каждого 
элемента будет равен трём колонкам, при размере вьюпорта 960px и меньше – четырём колонкам, при размере вьюпорта 768px и 
меньше – шести колонкам, и наконец, когда размер вьюпорта достигнет 640px, все элементы будут занимать по двенадцать 
колонок каждый, то есть будут занимать всё доступное пространство. Попроубуйте поизменять размер окна браузера, чтобы 
увидеть поведение сетки при различных размерах вьюпорта:

```html
<div class="container">
  <div class="row">
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">1</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">2</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">3</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">4</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">5</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">6</div>
  </div>
</div>
```

А вот код, который позволил построить эту сетку:

```scss
 .wrap {
   @include container;
 }
 
 .inner {
   @include row;
 }
 
 .column {
   @include col(2);
   @include col(3, laptop);
   @include col(4, laptop-md);
   @include col(6, tablet-landscape);
   @include col(12, phone-landscape);
 }
```

Давайте более подробно остановимся на миксине ```col``` и посмотрим все возможные варианты его вызова.

 - Когда мы вызываем миксин без аргументов:
 
   ```scss
   @include col;
   ```
   
   то наш элемент получает правила из блока ```@else```:
   
   ```scss
   flex: 1 0 0%;
   box-sizing: border-box;
   margin: 0 $h-gutter / 2 $v-gutter;
   ```
   
 - Когда мы вызываем миксин с одним аргументом, который является числом:
   
   ```scss
   @include col(3);
   ```
   то наш элемент получает правила из блока ```@else if```:
   
   ```scss
   width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
   flex: 0 0 auto;
   box-sizing: border-box;
   margin: 0 $h-gutter / 2 $v-gutter;
   ```
 - Если же при вызове миксина мы передаём ему оба аргумента, при этом значение первого аргумента – число, а значение 
   второго аргумента равно одному из имён ключей глобального массива ```$grid-breakpoints``` (desktop, laptop, phone и т. д.):
   
   ```scss
   @include col(3, laptop);
   ```
   
   то к элементу применятся правила из блока ```@if```:
   
   ```scss
   @media screen and(#{$media-query}-width: map-get($grid-breakpoints, $breakpoint)) {
     width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
     flex: 0 0 auto;
     box-sizing: border-box;
     margin: 0 $h-gutter / 2 $v-gutter;
   }
   ```
   
 - Во всех остальных случаях элемент получит правила из блока ```@else```, так, как будто миксин был вызван без аргументов.
 
# Генерация готовых колоночных классов в медиазпросах

Далее по аналогии с тем, как мы создали код, генерирующий классы контейнера, ряда и колонок, мы должны создать код, 
генерирующий готовые классы колонок с медиазапросами, чтобы иметь возможность строить сетку, просто добавляя классы в нашу
html-разметку. В файл ```mixins/_grid.scss``` я добавляю два новых миксина, код которых будет подробно разобран ниже.

mixins/_grid.scss:

```scss
@mixin generate-breakpoint($cols, $screen-width, $name) {
  .col-#{$name}-#{$cols} {
    @media screen and (#{$media-query}-width: $screen-width) {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter}) !important;
      flex: auto 0 0;
    }
  }
}

@mixin generate-grid-breakpoints($cols: $columns, $breakpoints: $grid-breakpoints) {
  @for $i from 1 through $cols {
    @each $name, $value in $breakpoints {
      @include generate-breakpoint($i, $value, $name);
    }
  }
}
```

Первый миксин вспомогательный и используется внутри второго миксина. Давайте разберём каждый из них более 
подробно. 

Миксин ```generate-breakpoint``` генерирует "колоночный" класс вида ```.col-tablet-8```, ```.col-laptop-12```, 
```.col-phone-landscape-3```, ```.col-desktop-6``` и т. д. Имя класса генерируется по следующему принципу: к строке '.col-' 
добавляется название брейкпойнта, которое берется из значения имени одного из ключей глобального массива 
```$grid-breakpoints```. Затем к получившейся строке через дефис добавляется число, означающее количество колонок – 
.col-laptop-5. Во второй строке для получившегося класса в соответствии с переданнами аргументами в медиазапросе задаются 
правила.

Миксин ```generate-grid-breakpoints``` генерирует все "колоночные" классы сетки и css-правила для них в медиазапросах 
исходя из глобальной переменной $columns – заданного количества колонок сетки и глобальной переменной 
```$grid-breakpoints``` – ассоциативного массива с брейкпойнтами. Миксин содержит цикл, который выполняет ```$cols``` 
итераций (по умолчанию 12, в соответсвии количеством колонок сетки). На каждой итерации внутри этого цикла по массиву 
```$breakpoints``` вызвается ещё один цикл, внутри которого вызывается миксин ```generate-breakpoint```, в который 
передаются ```$i``` – количество колонок, ```$value``` – ширина экрана и ```$name``` – название брейкпойнта.

Вот полный код файла ```mixins/_grid.scss``` с комментариями:

```scss
// превращает элемент в контейнер сетки
@mixin container {
  max-width: $container-width;
  margin: 0 auto;
  padding: 0 $container-padding;
}

// превращает элемент в строку сетки
@mixin row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -#{$h-gutter / 2};
}

/*
  Превращает элемент в ячейку сетки размером в $cols колонок.
  Если при вызове примеси не передан ни один аргумент, к элементу будут применены правила, согласно которым элемент
  будет компоноваться как флекс-элемент и будет занимать пространство, равное занимаемому пространству соседними
  флекс-элментами
  Если при вызове примеси переданы оба аргумента и при этом тип первого аргумента $cols - число, а значение второго
  аргумента соответвствует одному из имен свойств глобального объекта $grid-breakpoints, то правило применяется только
  в медиазапросе, значение которого берется из этого второго аргумента. При этом в качестве значения второго аргумента
  должно использоваться одно из имен ключей глобального объекта $grid-breakpoints
  Если же передан только первый аргумент или значение второго аргумента не соответствует
  ни одному из имен ключей глобального объекта $grid-breakpoints, то элемент будет просто занимать количество ячеек,
  равное $cols
*/
@mixin col($cols: 'false', $breakpoint: 'false') {

  @if ($breakpoint != 'false' and map_has_key($grid-breakpoints, $breakpoint) and $cols != 'false' and type_of($cols) == number) {

    @media screen and(#{$media-query}-width: map-get($grid-breakpoints, $breakpoint)) {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
      flex: 0 0 auto;
      box-sizing: border-box;
      margin: 0 $h-gutter / 2 $v-gutter;
    }

  } @else if ($breakpoint == 'false' and $cols != 'false' and type_of($cols) == number) {
    width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  } @else {
    flex: 1 0 0%;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}

// рассчитывает ширину столбца в зависимости от переданного количества столбцов $cols
@function col-width($cols: 1) {
  @return calc(100% / #{$columns} * #{$cols} - #{$h-gutter});
}

/*
  Генерирует "колоночные" классы вида .col-1, .col-2, .col-3 и т.д. исходя из глабальной переменной $columns - заданного
  количества колонок сетки
*/
@mixin generate-grid($cols: $columns) {
  @for $i from 1 through $cols {
    .col-#{$i} {
      width: col-width($i);
    }
  }
}

/*
  Генерирует "колоночный" класс сетки вида .col-tablet-8 и css-правила для него в медиазапросе исходя из $cols - числа
  столбцов, $screen-width - ширины экрана и $name - названия брейкпойнта, значение которого должно соответсвовать одному
  из имен ключей глобального объекта $grid-breakpoints
*/
@mixin generate-breakpoint($cols, $screen-width, $name) {
  .col-#{$name}-#{$cols} {
    @media screen and (#{$media-query}-width: $screen-width) {
      width: calc(100% / #{$columns} * #{$cols} - #{$h-gutter}) !important;
      flex: auto 0 0;
    }
  }
}

/*
  Генерирует "колоночные" классы сетки и css-правила для них в медиазапросе исходя из глобальной переменной
  $columns - заданного количества колонок сетки и глобальной переменной $grid-breakpoints - объекта с брейкпойнтами
*/
@mixin generate-grid-breakpoints($cols: $columns, $breakpoints: $grid-breakpoints) {
  @for $i from 1 through $cols {
    @each $name, $value in $breakpoints {
      @include generate-breakpoint($i, $value, $name);
    }
  }
}
```

А это полный код файла ```base.scss``` с учетом генерации классов в медиазапросах:

```scss
.container {
  @include container;
}

.row {
  @include row;
}

.col {
  @include col;
}

/*
  Генерация "колоночных" классов и правил для них исходя из глобальной переменной $columns - заданного количества
  столбцов сетки
*/
@for $i from 1 through $columns {
  .col-#{$i} {
    flex: 0 0 auto;
    box-sizing: border-box;
    margin: 0 $h-gutter / 2 $v-gutter;
  }
}

// генерация "колоночных" классов
@include generate-grid();

// генерация "колоночных" клоссов с медиазапросами
@include generate-grid-breakpoints();
```

Теперь мы можем строить сетку не только в sass, но и в html: 

```html
<div class="container">
  <div class="row">
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">1</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">2</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">3</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">4</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">5</div>
    <div class="col-2 col-laptop-3 col-laptop-md-4 col-tablet-landscape-6 col-phone-landscape-12">6</div>
  </div>
</div>
```

```bash
пример результат
```

# Дальнейшие шаги

К настоящему моменту у нас реализован основной функционал нашей системы – мы можем строить адаптивную сетку с колонками 
разных размеров. Причём размеры колонок могут меняться в зависимости от размера экрана устройства, так как сетка 
поддерживает медиазапросы. Хотя данного функционала достаточно для построения гибкой адаптивной сетки, однако его 
недостаточно, чтобы считать такую сетку полноценной. Поэтому все дальнейшие шаги, которые мы реализуем, как раз и будут 
направлены на наращивание этого дополнительного функционала.

Вот список того, что мы реализуем дальше:
  - выравнивание колонок внутри ряда
  - направление расположения колонок
  - смещение колонок
  - изменение порядка расположения колонок
  - скрытие и отображение элементов внутри колонок
  - сброс внешних отступов у рядов и колонок
  
# Выравнивание колонок внутри ряда

Выравнивание колонок внутри ряда – это по сути то же самое, что и выравнивание флекс-элементов внутри флекс-контейнера. 
Ведь фактически колонки сетки и есть флекс-элементы внутри ряда сетки – флекс-контейнера. А как нам известно, для 
флекс-элементов существует два вида выравнивания – выравнивание вдоль главной оси и выравнивание вдоль поперечной оси. 
Лучше продемонстрировать это наглядно.

Выравнивание колонок вдоль главной оси:

Колонки распологаются вначале ряда:

```html
<div class="container">
  <div class="row justify-content-start">
  <div class="col-2">col</div>
  <div class="col-2">col</div>
  </div>
</div>
```

Колонки распологаются по центру ряда:

```html
<div class="container">
  <div class="row justify-content-center">
  <div class="col-2">col</div>
  <div class="col-2">col</div>
  </div>
</div>
```

Колонки распологаются в конце ряда:

```html
<div class="container">
  <div class="row justify-content-end">
  <div class="col-2">col</div>
  <div class="col-2">col</div>
  </div>
</div>
```
Колонки распологаются равномерно по ширине ряда. Аналог <span class='code'>justify-content: space-between</span>:

```html
<div class="container">
  <div class="row justify-content-space-between">
  <div class="col-2">col</div>
  <div class="col-2">col</div>
  </div>
</div>
```

Колонки распологаются равномерно по ширине ряда и имеют полуразмерное пространство. 
Аналог<span class='code'>justify-content: space-around</span>:
```html
<div class="container">
  <div class="row justify-content-space-around">
  <div class="col-2">col</div>
  <div class="col-2">col</div>
  </div>
</div>
```

Выравнивание колонок вдоль поперечной оси:

Колонки распологаются в начале ряда:

```html
<div class="container">
  <div class="row align-items-start">
  <div class="col">col</div>
  <div class="col">col</div>
  </div>
</div>
```

Колонки распологаются по центру ряда:

```html
<div class="container">
  <div class="row align-items-center">
  <div class="col">col</div>
  <div class="col">col</div>
  </div>
</div>
```

Колонки распологаются в конце ряда:

```html
<div class="container">
  <div class="row align-items-end">
  <div class="col">col</div>
  <div class="col">col</div>
  </div>
</div>
```

Колонки имеют "авто-размер", подстраиваясь под размер контейнера. Аналого <span class='code'>align-items: stretch</span>:

```html
<div class="container">
  <div class="row align-items-end">
  <div class="col">col</div>
  <div class="col">col</div>
  </div>
</div>
```

Выравнивание отдельно взятой колонки вдоль поперечной оси:

По центру ряда:

```html
<div class="container">
  <div class="row">
    <div class="col align-self-center"></div>
    <div class="col"></div>
  </div>
</div> 
```

Теперь давайте посмотрим, как реализовать такой функционал.

Для начала в директорию с миксинами <span class='code'>mixins</span> добавим новый файл <span class='code'>_alignment</span>, 
в котором и будет храниться код, отвечающий за выравнивание элементов. Первым делом добавим миксин, отвечающий за 
вырвнивание колонок вдоль главной оси: 

```scss
@mixin justify-content($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      justify-content: $align;
    }
  } @else {
    justify-content: $align;
  }
}
```

Миксин принимает на вход два параметра – <span class='code'>$align</span> и <span class='code'>$breakpoint</span>.
Параметр <span class='code'>$align</span> задаёт способ выравнивания колонок и может принимать одно из следующих значений: 
<span class='code'>flex-start</span>, <span class='code'>center</span>, <span class='code'>flex-end</span>, 
<span class='code'>space-between</span>, <span class='code'>space-around</span>. По умолчанию колонки располагаются 
вначале ряда.

Параметр <span class='code'>$breakpoint</span> определяет, будет ли выравнивание колонок применяться внутри медиазапроса. 
Если при вызове миксина ему будет передан второй аргумент и его значение будет соответствовать одному из имён ключей 
глобального массива <span class='code'>$grid-breakpoints</span>, то заданное выравнивание сработает в медиазапросе.
То есть, если мы вызовем миксин так:

```scss
.some {
  @include justify-content(flex-end);
}
```

тогда элемент будет расположен в конце ряда.

Если же мы вызовем миксин так:

```scss
.some {
  @include justify-content(flex-end, laptop);
}
```

тогда элемент будет расположен в конце ряда, когда размер вьюпорта будет равен 1024px и меньше.

Аналогично добавим миксин, отвечающий за выравнивание колонок вдоль поперечной оси:

```scss
@mixin align-items($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-items: $align;
    }
  } @else {
    align-items: $align;
  }
}
```

Этот миксин очень похож на предыдущий, за исключением того, что параметр <span class='code'>$align</span> задаёт 
выравнивание колонок вдоль поперечной оси и должен принимать сдедующие значения: <span class='code'>flex-start</span>, 
<span class='code'>flex-end</span>, <span class='code'>center</span>, <span class='code'>stretch</span>, 
<span class='code'>baseline</span>.

И наконец добавим последний миксин, отвечающий за выравнивание отдельно взятой колонки вдоль поперечной оси:

```scss
@mixin align-self($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-self: $align;
    }
  } @else {
    align-self: $align;
  }
}
```

Опять же, отличие данного миксина от двух предыдущих в том, что параметр <span class='code'>$align</span> задаёт 
выравнивание отдельно взятой колонки внутри ряда, но должен принимать те же значения, что и в предыдущем миксине: 
<span class='code'>flex-start</span>, <span class='code'>flex-end</span>, <span class='code'>center</span>, 
<span class='code'>stretch</span>, <span class='code'>baseline</span>.

Полный на данный момент код файла <span class='code'>mixins/_alignment.scss</span>:

```scss
@mixin justify-content($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      justify-content: $align;
    }
  } @else {
    justify-content: $align;
  }
}

@mixin align-items($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-items: $align;
    }
  } @else {
    align-items: $align;
  }
}

@mixin align-self($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-self: $align;
    }
  } @else {
    align-self: $align;
  }
}
```

Как мы помним, нам также нужно сгенерировать готовые предопределённые классы, которые позволят нам строить сетку 
исключительно в html-разметке. В директорию <span class='code'>partials</span> добавим файл <span class='code'>alignment.scss</span> 
и напишём в нём такой код:

```scss
.justify-content-start {
  @include justify-content(flex-start);
}

.justify-content-center {
  @include justify-content(center);
}

.justify-content-end {
  @include justify-content(flex-end);
}

.justify-content-space-between {
  @include justify-content(space-between);
}

.justify-content-space-around {
  @include justify-content(space-around);
}

.align-items-start {
  @include align-items(flex-start);
}

.align-items-center {
  @include align-items(center);
}

.align-items-end {
  @include align-items(flex-end);
}

.align-items-stretch {
  @include align-items(stretch);
}

.align-items-baseline {
  @include align-items(baseline);
}

.align-self-start {
  @include align-self(flex-start);
}

.align-self-center {
  @include align-self(center);
}

.align-self-end {
  @include align-self(flex-end);
}

.align-self-stretch {
  @include align-self(stretch);
}

.align-self-baseline {
  @include align-self(baseline);
}
```

В этих классах нет ничего особенного, они всего лишь подключают написанные выше миксины, тем самым добавляя правила 
выравнивания.

Как мы помним, вторым параметром наши миксины принимают имя брейкпойнта, при котором срабатывает выравнивание. Это значит, 
что наш код также должен генерировать классы выравнивания в медиазапросах. Чтобы было понятнее, я добавлю миксин, который 
при вызове генерирует "выравнивающие" классы в медиазапросах. Итак, в файл <span class='code'>mixins/_alignment</span> я 
добавляю следующий миксин:

```scss
@mixin generate-h-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $h-alignment-classes {
      .justify-content-#{$breakpoint-name}-#{$className} {
        @include justify-content($value, $breakpoint-name);
      }
    }
  }
}
```

Как видите, у нас появилась новая переменная <span class='code'>$h-alignment-classes</span>. Поэтому также добавим её в 
начало файла <span class='code'>mixins/_alignment</span>:

```scss
$h-alignment-classes: (
  start: flex-start,
  center: center,
  end: flex-end,
  between: space-between,
  around: space-around,
);
```
<span class='code'>$h-alignment-classes</span> – это массив, содержащий пары "ключ-значение", который нужен нам внутри 
миксина <span class='code'>generate-h-alignment-breakpoints</span>. Стоит более подробно рассмотреть этот миксин. Внутри 
миксина выполняется двойной цикл. Внешний цикл совершает проход по списку брейкпойнтов, хранящихся в глобальной переменной 
<span class='code'>$grid-breakpoints</span>. На каждой итерации этого цикла выполняется внутринний цикл, совершающий 
проход по списку <span class='code'>$h-alignment-classes</span>. В свою очередь на каждой итерации внутреннего цикла 
происходит формирование "выравнивающего" класса, внутри которого происходит подключение миксина, отвечающего за добавление 
правил, необходимых для выравнивания элемента вдоль основной оси. Причём все правила выравнивания формируются внутри 
директивы <span class='code'>@media</span>.

То есть в итоге вызов миксина сгенерирует классы вида: <span class='code'>.justify-content-desktop-start</span>, 
<span class='code'>.justify-content-laptop-center</span>, <span class='code'>.justify-content-phone-end</span> и т. д. 

Аналогично я добавлю ещё два миксина, отвечающих за генерирование классов, "выравнивающих" колонки вдоль поперечной 
оси, и классов, "выравнивающих" отдельно взятую колонку вдоль поперечной оси внутри ряда сетки:

```scss
@mixin generate-v-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $v-alignment-classes {
      .align-items-#{$breakpoint-name}-#{$className} {
        @include align-items($value, $breakpoint-name);
      }
    }
  }
}

@mixin generate-self-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $v-alignment-classes {
      .align-self-#{$breakpoint-name}-#{$className} {
        @include align-self($value, $breakpoint-name);
      }
    }
  }
}
```

И снова в начало файла добавлю дополнительную переменную:

```scss
$v-alignment-classes: (
  start: flex-start,
  center: center,
  end: flex-end,
  stretch: stretch,
  baseline: baseline
);
```

Эти два дополнительных миксина не нуждаются в подробном разборе, так как они по своему принципу действия аналогичны 
предыдущему миксину. Единственно, что стоит упомянуть, это то, что миксины генерируют классы, отвечающие за выравнивание 
элементов вдоль поперечной оси.

Теперь нам нужно вызвать эти миксины, чтобы сгенерировать все необходимые классы. Добавим вызов миксинов в файл 
<span class='code'>partials/alignment</span>:

```scss
// генерация "выравнивающих" классов вдоль главной оси внутри медиазапросов
@include generate-h-alignment-breakpoints();
// // генерация "выравнивающих" классов вдоль поперечной оси внутри медиазапросов
@include generate-v-alignment-breakpoints();
// // генерация "выравнивающих" классов вдоль главной оси внутри медиазапросов для отдельно взятой колонки
@include generate-self-alignment-breakpoints();
```

А теперь приведу полоный код с подробными комментариями.

mixins/_alignment.scss:

```scss
/* Выравнивание колонок внутри ряда вдоль основной и поперечной осей */

$h-alignment-classes: (
  start: flex-start,
  center: center,
  end: flex-end,
  between: space-between,
  around: space-around,
);

$v-alignment-classes: (
  start: flex-start,
  center: center,
  end: flex-end,
  stretch: stretch,
  baseline: baseline
);

/* ГОРИЗОНТАЛЬНОЕ ВЫРАВНИВАНИЕ */

/*
  Выкладывает колонки сетки в ряду согласно параметру $align, который должен принимать одно из следующих значений:
  flex-start, flex-end, center, space-between, space-around.
  Применяется к элементам ряда ($row) сетки.
  Если передан аргумент $breakpoint, выравнивание сработает в медиазапросе согласно значению этого аргумента.
  Значением аргумента должно быть одно из имен ключей глобального массива $grid-breakpoints.
*/
@mixin justify-content($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      justify-content: $align;
    }
  } @else {
    justify-content: $align;
  }
}

/* ВЕРТИКАЛЬНОЕ ВЫРАВНИВАНИЕ */

/*
  Выкладывает колонки сетки в ряду согласно параметру $align, который должен принимать одно из следующих значений:
  flex-start, flex-end, center, stretch, baseline.
  Применяется к элементам ряда ($row) сетки.
  Если передан аргумент $breakpoint, выравнивание сработает в медиазапросе согласно значению этого аргумента.
  Значением аргумента должно быть одно из имен ключей глобального массива $grid-breakpoints.
*/
@mixin align-items($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-items: $align;
    }
  } @else {
    align-items: $align;
  }
}

/*
  Выкладывает отдельно взятую колонку сетки в ряду согласно параметру $align, который должен принимать одно из следующих значений:
  flex-start, flex-end, center, stretch, baseline.
  Применяется к элементу отдельно взятой колонки ($col).
  Если передан аргумент $breakpoint, выравнивание сработает в медиазапросе согласно значению этого аргумента.
  Значением аргумента должно быть одно из имен ключей глобального массива $grid-breakpoints.
*/
@mixin align-self($align: flex-start, $breakpoint: null) {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @media screen and(#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
      align-self: $align;
    }
  } @else {
    align-self: $align;
  }
}

/*
  Генерирует классы выравнивания колонок сетки вдоль главной оси. Внутри класоов правила генерируются внутри директивы 
  @media, то есть внутри медиазапроса. Например: .justify-content-desktop-start, .justify-content-laptop-center и т.д. 
  Применяется к элементам строки ($row). Для формирования классов и брейкпоинтов в медиазапросах использует массивы 
  $h-alignment-classes и $grid-breakpoints.
*/
@mixin generate-h-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $h-alignment-classes {
      .justify-content-#{$breakpoint-name}-#{$className} {
        @include justify-content($value, $breakpoint-name);
      }
    }
  }
}

/*
  Генерирует классы выравнивания колонок сетки вдоль поперечной оси. Внутри класоов правила генерируются внутри директивы 
  @media, то есть внутри медиазапроса. Например: .align-items-desktop-start, .align-items-laptop-center и т.д. 
  Применяется к элементам строки ($row).
  Для формирования классов и брейкпойнтов в медиазапросах использует массивы $v-alignment-classes и $grid-breakpoints.
*/
@mixin generate-v-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $v-alignment-classes {
      .align-items-#{$breakpoint-name}-#{$className} {
        @include align-items($value, $breakpoint-name);
      }
    }
  }
}

/*
  Генерирует классы выравнивания отдельно взятой колонки сетки вдоль поперечной оси.
  Внутри класоов правила генерируются внутри директивы @media, то есть внутри медиазапроса.
  Например: .align-self-desktop-start, .align-self-laptop-center и т.д. Применяется к элементам колонки ($col).
  Для формирования классов и брейкпойнтов в медиазапросах использует массивы $v-alignment-classes и $grid-breakpoints.
*/
@mixin generate-self-alignment-breakpoints() {
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    @each $className, $value in $v-alignment-classes {
      .align-self-#{$breakpoint-name}-#{$className} {
        @include align-self($value, $breakpoint-name);
      }
    }
  }
}
```

partials/alignment.scss:

```scss
.justify-content-start {
  @include justify-content(flex-start);
}

.justify-content-center {
  @include justify-content(center);
}

.justify-content-end {
  @include justify-content(flex-end);
}

.justify-content-space-between {
  @include justify-content(space-between);
}

.justify-content-space-around {
  @include justify-content(space-around);
}

.align-items-start {
  @include align-items(flex-start);
}

.align-items-center {
  @include align-items(center);
}

.align-items-end {
  @include align-items(flex-end);
}

.align-items-stretch {
  @include align-items(stretch);
}

.align-items-baseline {
  @include align-items(baseline);
}

.align-self-start {
  @include align-self(flex-start);
}

.align-self-center {
  @include align-self(center);
}

.align-self-end {
  @include align-self(flex-end);
}

.align-self-stretch {
  @include align-self(stretch);
}

.align-self-baseline {
  @include align-self(baseline);
}

// генерация "выравнивающих" классов вдоль главной оси внутри медиазапросов
@include generate-h-alignment-breakpoints();
// генерация "выравнивающих" классов вдоль поперечной оси внутри медиазапросов
@include generate-v-alignment-breakpoints();
// генерация "выравнивающих" классов вдоль главной оси внутри медиазапросов для отдельно взятой колонки
@include generate-self-alignment-breakpoints();
```

Теперь для выравнивания колонок мы можем воспользоваться как нашими миксинами, так и готовыми сгенерированными классами: 

```html
пример на html
```

```scss
пример на sass
```

В заключение этого раздела хотелось бы добавить ещё кое-что. Помните в начале я говорил о том, что пользователь сам волен 
выбрать, как ему строить сетку – добавлять готовые классы в разметку или же подключать готовые миксины в sass-файлах. 
Так вот, если пользователь решит использовать готовые миксины, то ему совсем необязательно генерировать большое 
количество предопределённых классов. Так вот, чтобы предотвратить генерацию классов, отвечающих за выравнивание колонок, 
мы обернём уже написанный код из файла <span class='code'>partials/alignment.scss</span> в условный блок так, как 
показано ниже:

```scss
@if index($partials, alignment) {

  .justify-content-start {
    @include justify-content(flex-start);
  }

  .justify-content-center {
    @include justify-content(center);
  }

  .justify-content-end {
    @include justify-content(flex-end);
  }

  .justify-content-space-between {
    @include justify-content(space-between);
  }

  .justify-content-space-around {
    @include justify-content(space-around);
  }

  .align-items-start {
    @include align-items(flex-start);
  }

  .align-items-center {
    @include align-items(center);
  }

  .align-items-end {
    @include align-items(flex-end);
  }

  .align-items-stretch {
    @include align-items(stretch);
  }

  .align-items-baseline {
    @include align-items(baseline);
  }

  .align-self-start {
    @include align-self(flex-start);
  }

  .align-self-center {
    @include align-self(center);
  }

  .align-self-end {
    @include align-self(flex-end);
  }

  .align-self-stretch {
    @include align-self(stretch);
  }

  .align-self-baseline {
    @include align-self(baseline);
  }

  // генерирация классов горизонтального выравнивания ячеек сетки в строке в медиазапросах
  @include generate-h-alignment-breakpoints();
  // генерация классов вертикального выравнивания ячеек сетки в столбце в медиазапросах
  @include generate-v-alignment-breakpoints();
  // генерация классов вертикального выравнивания отдельно взятой ячейки сетки в столбце в медиазапросах
  @include generate-self-alignment-breakpoints();
}
```

И переопределим нашу глобальную переменную <span class='code'>$partials</span> так, чтобы она больше не содержала элемент 
<span class='code'>alignment</span>.

Таким образом у нас не выполнится условие: 

```scss
@if index($partials, alignment) {
  // ...code
}
```

Напомню, что функция <span class='code'>index</span> вернёт позицию в списке для <span class='code'>alignment</span> или 
вернёт <span class='code'>null</span>, если элемент в списке не был найден. То есть найденная позиция интерпретируется как 
истинное значение условия, а <span class='code'>null</span> – как ложное.

Забегая вперёд скажу, что подобным образом мы реализуем остальные части нашей библиотеки, которые будут отвечать за 
генерацию предопределённых готовых классов. Для исключения тех или иных наборов классов мы можем переопределить переменную 
<span class='code'>$paritals</span>, хранящую список частей библиотеки, отвечающих за генерацию готовых классов. Мы 
можем вовсе отменить генерацию всех готовых классов, присвоив переменной <span class='code'>$partials</span> значение 
<span class='code'>false</span>, что значительно сократит скомпилированный css-файл нашей библиотеки.

# Направление расположения колонок

Направление колонок – это то, как будут выстраиваться колонки внутри ряда. Как и в случае с выравниванием колонок, лучше 
это продемонстрировать наглядно.

Направление по умолчанию – колонки располагаются слева направо вдоль основной оси:

```html
 пример
```

Колонки располагаются справа налево вдоль основной оси:

```html
пример
```

Колонки располагаются сверху вниз вдоль поперечной оси:

```html
пример
```

Колонки располагаются снизу вверх вдоль поперечной оси:
```html
пример
```

А теперь пошагово реализуем данный функционал. В директорию с нашими миксинами <span class='code'>mixins</span> я 
добавляю файл <span class='code'>_direction.scss</span>. Файл будет содержать миксин следующего содержания:

```scss
/* Направление расположения колонок в ряду */

/*
  Задает направление главной оси, вдоль которой укладываются колонки сетки в ряду.
  В качестве аргумента для первого параметра $direction должно быть передано одно
  из следующиех значений: row, row-reverse, column, column-reverse.
  Если вторым аргументом передано значение, соответствующее одному из имен ключей
  глобального массива $grid-breakpoints, правило будет применено в медиазапросе.
*/
@mixin direction($direction: row, $breakpoint: 'false') {
  @if (map_has_key($grid-breakpoints, $breakpoint)) {
    @if ($direction == row) {
      @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
        flex-direction: row;
      }
    } @else if ($direction == row-reverse) {
      @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
        flex-direction: row-reverse;
      }
    } @else if ($direction == column) {
      @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
        flex-direction: column;
      }
    } @else if ($direction == column-reverse) {
      @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
        flex-direction: column-reverse;
      }
    } @else {
      @media screen and (#{$media-query}-width: map_get($grid-breakpoints, $breakpoint)) {
        flex-direction: row;
      }
    }
  } @else {
    @if ($direction == row) {
      flex-direction: row;
    } @else if ($direction == row-reverse) {
      flex-direction: row-reverse;
    } @else if ($direction == column) {
      flex-direction: column;
    } @else if ($direction == column-reverse) {
      flex-direction: column-reverse;
    } @else {
      flex-direction: row;
    }
  }
}
```

Разберём код. На вход миксин принимает два параметра. Первый параметр отвечает за то, в каком направлении будут раполагаться 
колонки в ряду, и может принимать четыре значения: <span class='code'>row</span>, <span class='code'>row-reverse</span>, 
<span class='code'>column</span>, <span class='code'>column-reverse</span>. Если мы внимательно посмотрим на миксин, то 
увидим, что направление расположения колонок задаётся свойством <span class='code'>flex-direction</span>. Это неудивительно, 
ведь колонки – это флекс-элементы внутри флекс-контейнера – элемента ряда. Поэтому стоит добавить, что миксин имеет смысл 
вызывать лишь на элементе ряда сетки <span class='code'>row</span>. Второй параметр должен принимать одно из имён 
брейкпоинтов, которые хранятся в глобальном свойстве <span class='code'>$grid-breakpoints</span>: 
<span class='code'>desktop</span>, <span class='code'>laptop</span>, <span class='code'>laptop-md</span>, 
<span class='code'>tablet-landscape</span> и т.д.

Первой строкой внутри миксина условный оператор проверяет, содержит ли наш глобальный массив брейкпоинтов 
<span class='code'>$grid-breakpoints</span> элемент, имеющий ключ, имя которого соответствует аргументу, переданному в 
параметр <span class='code'>$breakpoint</span> при вызове миксина. Если условие выполняется, тогда все правила выравнивания 
оборачиваются директивой <span class='code'>@media</span>, то есть выполняются внутри медиазапроса. Если же условие не 
выполняется, тогда все правила выравнивания просто добавляются в селектор элемента.

Во второй строке и ниже по коду также присутствуют блоки условий, зависящие от первого параметра 
<span class='code'>$direction</span> и определяющие направление расположения колонок сетки.

И конечно, не забудем написать код, отвечающий за генерацию готовых "направляющих" классов. Для этого в директорию 
<span class='code'>partials</span> поместим файл <span class='code'>direction</span>. И напишем в нём такой код:

```scss
.direction-row {
  @include direction(row);
}

.direction-row-reverse {
  @include direction(row-reverse);
}

.direction-column {
  @include direction(column);
}

.direction-column-reverse {
  @include direction(column-reverse);
}
```

Этот код добавляет готовые "направляющие" классы, которыми мы можем воспользоваться "как есть", всего лишь прописав их 
в нашей html-разметке на нужных элементах страницы. Внутри себя селекторы классов всего лишь подключают написанные нами 
ранее миксины. Нам также необходимо добавить "направляющие" классы с медиазапросами. Для этого достаточно реализовать 
цикл, который пройдётся по массиву <span class='code'>$grid-breakpoints</span>, сгенерирует соответствующий имени 
брейкпоинта селектор класса и вызовет внутри него созданный нами ранее миксин 
<span class='code'>direction</span>, вторым параметром передав ему имена всех брейкпоинтов на каждом проходе цикла. Ведь 
как мы помним, если нашему миксину <span class='code'>direction</span> вторым параметром передать имя брейкпоинта, то 
заданные в результате правила будут обёрнуты в медиазапрос.

```scss
  // генерация "направляющих" классов в медиазапросах согласно заданным брейкпойнтам $grid-breakpoints
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    .direction-#{$breakpoint-name}-row {
      @include direction(row, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-row-reverse {
      @include direction(row-reverse, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-column {
      @include direction(column, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-column-reverse {
      @include direction(column-reverse, $breakpoint-name);
    }
  }
```

Этот код сгенерирует классы вида <span class='code'>direction-desktop-row</span>, <span class='code'>direction-laptop-column</span>,
<span class='code'>direction-phone-landscape-row-reverse</span> и т.д.

Полный код <span class='code'>partials/direction.scss</span>:

```scss
@if (index($partials, direction)) {

  .direction-row {
    @include direction(row);
  }

  .direction-row-reverse {
    @include direction(row-reverse);
  }

  .direction-column {
    @include direction(column);
  }

  .direction-column-reverse {
    @include direction(column-reverse);
  }

  // генерация "направляющих" классов в медиазапросах согласно заданным брейкпойнтам $grid-breakpoints
  @each $breakpoint-name, $breakpoint-value in $grid-breakpoints {
    .direction-#{$breakpoint-name}-row {
      @include direction(row, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-row-reverse {
      @include direction(row-reverse, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-column {
      @include direction(column, $breakpoint-name);
    }

    .direction-#{$breakpoint-name}-column-reverse {
      @include direction(column-reverse, $breakpoint-name);
    }
  }
}
```

Теперь мы можем задавать направление колонок как в html, так и в sass:

```html
пример на html
```

```scss
пример на scss
```

Оба варианта дадут аналогичный результат:

```bash
результат работы кода
```

Примеры.

```bash
примеры
```